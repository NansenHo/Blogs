# 黑客与画家（10万册纪念版）
—— 保罗·格雷厄姆
- [黑客与画家（10万册纪念版）](#黑客与画家10万册纪念版)
    - [推荐序 “黑客精神”过时了吗？答案是永远不会](#推荐序-黑客精神过时了吗答案是永远不会)
    - [保罗·格雷厄姆其人其事](#保罗格雷厄姆其人其事)
    - [平装版译者序](#平装版译者序)
    - [前言](#前言)
  - [黑客如何成长及看待世界](#黑客如何成长及看待世界)
    - [1 为什么书呆子不受欢迎 :star:](#1-为什么书呆子不受欢迎-star)
    - [2 黑客与画家 :star:](#2-黑客与画家-star)
    - [3 不能说的话](#3-不能说的话)
      - [你是一个随大流的人吗](#你是一个随大流的人吗)
      - [真话 :start:](#真话-start)
      - [异端邪说](#异端邪说)
      - [时空差异](#时空差异)
      - [道貌岸然 :start:](#道貌岸然-start)
      - [机制](#机制)
      - [为什么这样做](#为什么这样做)
      - [守口如瓶](#守口如瓶)
      - [笑脸相迎？](#笑脸相迎)
      - [永远质疑 :star:](#永远质疑-star)
  - [第二部分 黑客如何工作及影响世界](#第二部分-黑客如何工作及影响世界)
    - [4 良好的坏习惯](#4-良好的坏习惯)
    - [5 另一条路](#5-另一条路)
      - [下一个潮流？](#下一个潮流)
      - [用户的胜利](#用户的胜利)
      - [代码之城](#代码之城)
      - [软件的发布](#软件的发布)
      - [软件bug](#软件bug)
      - [客户支持](#客户支持)
      - [全身心投入](#全身心投入)
      - [逆向的《人月神话》](#逆向的人月神话)
      - [关注用户](#关注用户)
      - [金钱问题](#金钱问题)
      - [目标客户](#目标客户)
      - [桌面电脑](#桌面电脑)
      - [微软公司](#微软公司)
      - [创业公司](#创业公司)
      - [勉强够用的网页](#勉强够用的网页)
      - [为什么不尝试一下](#为什么不尝试一下)
    - [6 如何创造财富](#6-如何创造财富)
      - [一个命题](#一个命题)
      - [金钱不等于财富](#金钱不等于财富)
      - [大饼谬论](#大饼谬论)
      - [手工艺人](#手工艺人)
      - [工作是什么](#工作是什么)
      - [更努力地工作 :star:](#更努力地工作-star)
      - [可测量性和可放大性 :star:](#可测量性和可放大性-star)
      - [小团队 = 可测量性 :star:](#小团队--可测量性-star)
      - [高科技 = 可放大性 :star:](#高科技--可放大性-star)
      - [潜规则](#潜规则)
      - [用户数量](#用户数量)
      - [财富和权力](#财富和权力)
    - [7 关注贫富分化](#7-关注贫富分化)
      - [财富的老爹模式](#财富的老爹模式)
      - [偷窃](#偷窃)
      - [技术的杠杆效应](#技术的杠杆效应)
      - [公理的不同意见](#公理的不同意见)
    - [8 防止垃圾邮件的一种方法](#8-防止垃圾邮件的一种方法)
    - [9 设计者的品味](#9-设计者的品味)
  - [第三部分 黑客的工具和工作方法](#第三部分-黑客的工具和工作方法)
    - [10 编程语言解析](#10-编程语言解析)
      - [机器语言](#机器语言)
      - [高级语言](#高级语言)
      - [开放源码](#开放源码)
      - [语言的战争](#语言的战争)
      - [抽象性](#抽象性)
      - [安全带还是手铐](#安全带还是手铐)
      - [面向对象编程](#面向对象编程)
      - [文艺复兴](#文艺复兴)
    - [11 一百年后的编程语言](#11-一百年后的编程语言)
    - [12 拒绝平庸](#12-拒绝平庸)
      - [秘密武器](#秘密武器)
      - [Blub困境](#blub困境)
      - [创业公司的合气道](#创业公司的合气道)
    - [13 书呆子的复仇](#13-书呆子的复仇)
      - [为什么Lisp语言很特别](#为什么lisp语言很特别)
      - [向心力](#向心力)
      - [附录：编程能力](#附录编程能力)
    - [14 梦寐以求的编程语言](#14-梦寐以求的编程语言)
      - [外部因素](#外部因素)
      - [简洁](#简洁)
      - [可编程性](#可编程性)
      - [一次性程序](#一次性程序)
      - [函数库](#函数库)
      - [效率](#效率)
      - [时间](#时间)
      - [再设计](#再设计)
      - [梦寐以求的编程语言](#梦寐以求的编程语言)
    - [15 设计与研究](#15-设计与研究)
    - [致谢](#致谢)
    - [术语表](#术语表)

### 推荐序 “黑客精神”过时了吗？答案是永远不会

从三个维度去看这本书：第一是“黑客精神”和“创造者思维”；第二是“财富创造”；第三是“开拓未来”。

黑客精神的真谛是动手去创造性地解决问题。“解决问题”必须跟人的需求有关，需要持久地满足越来越多人的需求。“动手”需要有勇气，很务实，以行动为导向，除此以外，黑客还必须是一个积极向上的人。“创造性”则意味着不受束缚、敢于探索。

黑客精神还意味着独立思考，坚持说真话。“动手去创造性地解决问题”

能设计的人很多，但是有品味的人却很少。


### 保罗·格雷厄姆其人其事

“运营创业公司，每天都像在战斗；而为大公司工作，就像在窒息中挣扎。”

“我对他们说，选择天使投资人的时候，最好选择那些自己有过创业经验的人。”

比起那些令人叫好的创意，格雷厄姆更看重创始人的素质。他说：“我们从一开始就认识到，创始人本身比他的创意更重要。”他还认为，小团队更容易成功，创始人总数最好不要超过三个。其中一个原因是，创始人越多，股权越不容易平等分配，容易造成内耗。


### 平装版译者序

在本书中，“黑客”就是指最优秀的程序员，而不是入侵计算机系统的人。


### 前言

行为怪异的人和愤世嫉俗的人比普通人更可能成为黑客。


## 黑客如何成长及看待世界


### 1 为什么书呆子不受欢迎 :star: 

“任何一种艺术，不管是否重要，如果你想要在该领域出类拔萃，就必须全身心投入。”

“受欢迎”的英语单词是popular，这个词还有另一个意思，即“大众化的，多数人的”，比如popular support（民意的支持）。此处使用了双关语，作者既是说青少年的行为目的是得到同伴的关注和称赞，也是说青少年这样做是为了与群体保持一致。理解这一点，对理解这篇文章非常重要。后文中有些地方的“受欢迎”，用的也是这个双关的含义，下文不再一一说明。

要是不受欢迎仅仅意味着不受到关注，书呆子们可能觉得还能忍受。不幸的是，在学校里不受欢迎等同于被歧视和被欺负。

一般来说，成年人就不会去欺负书呆子。为什么小孩子会这样做呢？一个原因是，青少年在心理上还没有摆脱儿童状态，许多人会残忍地对待他人。

在一个人产生良知之前，折磨就是一种娱乐。

孩子们欺负书呆子的另一个原因是想让自己感到好受一些。

孩子们欺负书呆子的主要原因也与追求“受欢迎”的心理有关。怎样才能让自己更受欢迎？个人魅力只是很小的一方面，你应该更多地考虑如何结盟。秘诀就是不停地设法使自己与其他受欢迎的人变得关系更密切。没有什么比一个共同的敌人更能使得人们团结起来了。

不受欢迎是一种传染病，虽然善良的孩子不会去欺负书呆子，但是为了保护自己，也依然会与书呆子保持距离。

当你所做的事情能产生真实的效果，那就不仅仅是好玩而已了，发现正确的答案就开始变得重要了，这正是书呆子的优势所在。

大多数情况下，学生内部形成的团体没有一个共同目标。但是，等级关系却不会缺席，所以孩子们的等级是凭空创造出来的。

如果存在针对真正能力的外部测试，待在等级关系的底层也不会那么痛苦。球队的新人并不会怨恨老队员的球技，他希望有一天自己也能球技高超，所以很高兴有机会向老队员求教。老队员可能也会因此产生一种传帮带的光荣感（noblesseoblige）。最重要的是，老队员的地位是通过他们本身出色的能力获得的，而不是通过排挤他人获得的。

校园生活的两大恐怖之处——残忍和无聊——也是出于同样的原因。

虽然在怪人的群体中，绝不学习是一个很重要的价值观（至少看上去如此），但是从整体上看，怪人还是比其他孩子聪明。

那是因为你对成年人来说不再具有经济价值（与工业社会以前的时期相比），所以他们把你扔在学校里，一关就是好几年，你根本没有真正的事情可做。任何这种类型的组织都是可怕的生存环境。你根本不需要寻找其他的原因，就能解释为什么青少年是不快乐的。


### 2 黑客与画家 :star:

事实上，在我知道的所有行业中，黑客与画家最相像。

黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师和作家一样，黑客和画家都试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。

与其说优秀的软件设计师是工程师，还不如说是建筑师。

建筑师决定做什么，工程师想出怎么做。

“做什么”和“怎么做”不应该分得太开。如果你决定做一件事，却不知道怎么做，你就是在自找麻烦。

大学和实验室里的黑客，就不去做那些真正想做的事情（设计优美的软件）

要是黑客写论文，最好的情况下，写出来的也只是一些补充性的描述，不会具有太大的实际价值。黑客先开发了一个很酷的软件，然后就写一篇论文，介绍这个软件。论文变成了软件成果的展示。这种结合是错误的，常常会产生问题。为了配合研究性的论文主题，你很容易就把工作重点从开发优美的软件转向开发一些丑陋的东西。

人们对一个作家的评价，需要100年才能达成一致。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。

黑客搞懂“计算理论”（theory of computation）的必要性，与画家搞懂颜料化学成分的必要性差不多大。

黑客新想法的最佳来源，并非那些名字里有“计算机”三个字的理论领域，而是其他创作领域。

你把整个程序想清楚的时间点，应该是在编写代码时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样。

它意味着，编程语言首要的特性应该是允许动态扩展。编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。

静态类型是某些计算机语言的一个特性，指编译时对变量类型进行严格检查，典型代表是C、C++和Java。在这一类语言中，在声明变量时，必须指定类型，而且以后不能再改变。这必然意味着，只有在你对整个程序流程和细节思考成熟以后，才能编写代码。与之对应的则是动态类型语言，变量包含的数据类型可以随时改变。

大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。

等我来到雅虎以后，发现在他们看来，“黑客”的工作就是用软件实现某个功能，而不是设计软件。在那里，程序员被当作技工，职责就是将产品经理的“构想”（如果这个词是这么用的话）翻译成代码。

大部分公司不把设计软件的职责交给一个优秀的黑客，而是交给一个委员会，黑客的作用仅仅是实现那个委员会的设计。

真正竞争软件设计的战场是新兴领域的市场，这里还没有人建立过防御工事。只要你能做出大胆的设计，由一个人或一批人同时负责设计和实现产品，你就能在这里战胜大公司。

如果你想赚钱，你可能不得不去干那些很麻烦很令人讨厌的事情，因为这些事情没人愿意义务来干。

如何才能做自己喜欢的事情？我认为这个问题的解决方法是一个几乎所有创作者都知道的方法：找一份养家糊口的“白天工作”（day job）。

更一般地说，“白天工作”的意思是，你有一份为了赚钱的工作，还有一份为了爱好的工作。

几乎所有的创作者在职业生涯的早期都有一份“白天工作”。画家和作家尤其显著。

摄影技术对绘画造成的最大伤害，也许就是消灭了画家最好的“白天工作”。

黑客更像创作者，而不是科学家

应该如何学习编程。画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。

如果你把一个画家的作品按照时间顺序排列，就会发现每幅画所用的技巧，都是建立在上一幅作品学到的东西之上。某幅作品如果有特别出色之处，你往往能够在更早的作品中发现一个小规模的初期版本。

应该定期地从头开始，而不要长年累月地在一个项目上不断工作，并且试图把所有的最新想法都以修订版的形式包括进去。

创作者的另一个学习途径是通过范例。对画家来说，博物馆就是美术技巧的图书馆。几百年来，临摹大师的作品一直是传统美术教育的一部分，因为临摹迫使你仔细观察一幅画是如何完成的。

黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。开源运动最鲜为人知的优点之一，就是使得学习编程变得更容易了。

过早优化是一件危险的事情。

我们应该对“过早设计”也抱有同样的担忧，不要太早决定一个程序应该怎么做。

达·芬奇不这样想。他对作品每一部分的认真程度完全不取决于预料中会不会有人仔细看这个部分。

坚持一丝不苟，就能取得优秀的成果，因为那些看不见的细节累加起来，就变得可见了。

优秀的软件也要求对美的狂热追求。如果你查看优秀软件的内部，就会发现那些预料中没有人会看见的部分也是优美的。我对待代码的认真程度远远超过我对待其他事情，如果我以这种态度对待日常生活的每件事，那么我就够资格找心理医生开处方药了。看到代码前面的缩进乱七八糟，或者看到丑陋的变量名，都会把我逼疯的。

黑客就像画家，工作起来是有心理周期的。有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作16个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。

你可以把bug留到以后解决。

消灭bug的过程就像解一道数学题，已知许许多多的约束条件，你只要根据条件对方程求解就可以了。你的程序应该能产生x 结果，却产生了y 结果。哪里出错了？你知道自己最后肯定能解决这个问题，所以做起来就很轻松，就好像刷墙一样，接近于休闲了。

当多个画家共同创作一幅作品时，每个人画的部分都是不一样的。通常来说，大师负责画主要人物，助手们负责画次要人物和背景。但是，你肯定找不到某个部分是两个人一起画的。
我认为，这也是多人共同开发一个软件的正确模式。需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。最终，它就会变得像一个公用杂物间，没人管理，又脏又乱，到处堆满了冗余代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。

黑客必须像画家一样，时刻考虑到用户的人性需要，这样才能做出伟大的产品。你必须能够站在用户的角度思考问题，也就是说，你必须学会“换位思考”。

事实表明，从他人的角度思考问题正是成功的奥秘所在。

普通黑客与优秀黑客的所有区别之中，会不会“换位思考”可能是最重要的单个因素。有些黑客很聪明，但是完全以自我为中心，根本不会设身处地为用户考虑。这样的人很难设计出优秀软件，因为他们不从用户的角度看待问题。1

判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。

程序必须写得能够供人们阅读，偶尔供计算机执行。

把代码写得便于阅读，并不是让你塞进去很多注释。

只有在那些不太成熟、容易出现问题的地方，你才应该加上注释，提醒读者注意，就好像公路上只有在急转弯处才会出现警示标志一样。

虽然我必须承认，眼下看来艺术家比黑客更酷，但是我们不应忘记，古时候绘画蓬勃发展的那些黄金年代，画家也不是像今天这样酷的。

看到这种模式反复出现。在一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。编程目前好像就处在这个阶段。

在达·芬奇的年代，绘画并不是一件很酷的事情，达·芬奇用自己的工作推动绘画成为一种伟大的表达方式。同样，编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。


### 3 不能说的话

真正令人惊恐的是，流行一时的不仅有衣服，还有道德观念。明明是专横武断、毫无依据的错误观点，大多数人却深信不疑，受到影响而不自知。这是非常危险的。流行的衣服，其实是很难看的衣服；流行的道德观念，其实不是善而是恶。但是，如果别人都穿流行的衣服，而你不穿，你就会遭到嘲讽；如果别人都遵守流行的道德观念，而你不遵守，结果则要严重得多，你会被解雇、流放、监禁，甚至被杀。

不管哪一个年代，有一件事都是不会改变的，那就是“祸从口出”。你一定要小心自己说的话。自以为无害的言论会给你惹来大麻烦。

现在我们言之凿凿的东西，在未来人们的眼里却是荒诞不经的，怎能不令人感叹呢！


#### 你是一个随大流的人吗

如果别人告诉你应该相信什么，你就真的相信了，那么你就会和别人犯下同样的错误。


#### 真话 :start:

如果伽利略说帕多瓦城的人身高3米，他只会被当作一个古怪的疯狂科学家。但是，他说地球围绕太阳运转，性质就完全不一样了。教廷知道，这种话会让人们开始思考。


#### 异端邪说

关注“异端邪说”，是找出“不能说的话”的第二种方法。


#### 时空差异

如果某个观点在大部分时空是不受禁止的，只有我们这个社会才把它当作禁忌，那么很可能是我们出错了。


#### 道貌岸然 :start:

孩子从家长那里得到一个错误的印象，以为它们是没人用的。为什么家长要这样伪装呢？因为他们觉得孩子不应该知道成年人语言的所有内容，只需知道一部分适合儿童的词就行了。我们喜欢孩子们看上去天真无邪。

没过多久，一切就变得有点像讽刺剧了。家长在外使用这些词，回家后就不用。孩子在外也使用这些词，回家后也不用。双方见面，就像演戏一样。

孩子“被迫”在一个精心设计的环境中长大。他的头脑或多或少是纯洁无瑕的，一点也不知道那些“不能说的话”，从来没有被真实的社会生活“污染”过。孩子眼里的世界是不真实的，是一个被灌输进他们头脑的假想世界。将来当孩子长大以后接触社会，就会发现小时候以为真实的事情，在现实世界中是荒唐可笑的。

> :question: 毫无顾忌在自己小孩面前说脏话，不让小孩在精心设计的环境中长大，是不是更好呢？


#### 机制

某种道德观念到底是怎么出现的，又是怎么被其他人接受的？如果我们能够理解它的产生机制，可能就可以应用于我们自己的时代。

流行的时尚产生于某个有影响力的人物，他突发奇想，接着其他人纷纷模仿。

流行的道德观念不是这样，它们往往不是偶然产生的，而是被刻意创造出来的。如果有些观点我们不能说出口，原因很可能是某些团体不允许我们说。

道德禁忌的最主要制造者是那些在权力斗争中略占上风的一方。你会发现，这一方有实力推行禁忌，同时又软弱到需要禁忌来保护自己的利益。

不管实际上是否有思想斗争，斗争总是会以思想斗争的形式表现出来。

虽然流行的思想观点与流行服饰的产生方式不尽相同，但是它们的传播途径却很相似。第一批接受者总是带有很强的抱负心，他们有自觉的精英意识，想把自己与普通人区分开来。当流行趋势确立以后，第二批接受者就加入进来了，人数比上一批庞大得多，恐惧心在背后驱使着他们。12他们接受流行，不是因为想要与众不同，而是因为害怕与众不同。

带动流行的两种力量之中，恐惧心比抱负心有力得多。


#### 为什么这样做

做一个异端是有回报的，不仅在科学领域，在任何有竞争的地方，只要你能看到别人看不到或不敢看的东西，你就有很大的优势。


#### 守口如瓶

有一天，你终于觉醒了，意识到错的不是黄颜色，而是这个社会。

自由思考比畅所欲言更重要。如果你感到一定要跟那些人辩个明白，绝不咽下这口气，一定要把话说清楚，结果很可能是从此你再也无法自由理性地思考了。我认为这样做不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。我就鼓励自己在心里默默思考那些最无法无天的想法。你的思想是一个“地下组织”，绝不要把那里发生的事情一股脑说给外人听。

“i pensieri stretti & il viso sciolto”。字面意思是“守口如瓶，笑脸相迎”，也就是说，你要对每一个人微笑，但是不要说出自己的真实想法。这是很明智的建议。因为弥尔顿是一个喜欢争论、好打嘴仗的人，而当时罗马教廷的宗教裁判所非常强势，所以沃顿爵士才会这样建议他。

弥尔顿的时代与我们的时代并没有本质不同。每个时代都有自己的忌讳，如果你触犯它们，就算没有坐牢，至少也会为自己惹来麻烦，干扰正常生活。

“守口如瓶”看上去是一种“怯懦”的行为。可是问题在于，“不能说的话”太多了，如果口无遮拦，你就没时间做正事了。

“守口如瓶”的真正缺点在于，你从此无法享受讨论带来的好处了。讨论一个观点会产生更多的观点，不讨论就什么观点也没有。所以，如果可能的话，你最好找一些信得过的知己，只与他们畅所欲言、无所不谈。这样不仅可以获得新观点，还可以用来选择朋友。能够一起谈论“异端邪说”并且不会因此气急败坏的人，就是你最应该认识的朋友。


#### 笑脸相迎？

狂热分子都有一个共同点：缺乏幽默感。他们无法平静地对待笑话。


#### 永远质疑 :star:

不管问谁，人们都会说同样的话：“我们心态很开放，愿意接受新思想。”但是实际上，人们脑子里有一条界线，早就认准了什么是对的，什么是错的。

只有保持一定的距离，才能观察到人们观念的变化，发现流行（也就是人们自以为正确的事情）到底是什么。

时间就是一种产生距离的简单方法。实际上，新的流行让旧的流行更容易被观察到，因为对比之下，旧的流行会显得很荒唐。从钟摆摆动的起点看，终点就显得特别遥远。

想要摆脱你自己所处的时代的流行，需要一点自觉。没有时间所产生的距离，你就不得不自己创造距离。你不要让自己成为人群的一分子，而要尽可能地远离人群，观察正在发生的事情，特别注意那些被压制的思想观点。

如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。只要不是错的观点，有关它的讨论就不应该被压制。所以每当你看到有些话被攻击为出自“××分子”或“××主义”，这就是一个明确的信号，表明背后有问题。

如果你发现自己也在用这些标签，那就更要问为什么。你不仅要远距离观察人群，更要远距离观察你自己。

如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。

如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑：什么话是我不能说的？为什么？


## 第二部分 黑客如何工作及影响世界


### 4 良好的坏习惯

在程序员眼里，“黑客”指的是优秀程序员。

“黑客”这个词的字面意思主要就是“精通”，也就是他可以随心所欲地支配计算机。

丑陋的做法与聪明的做法存在一个共同点，那就是都不符合常规。

在计算机工业的历史上，新技术往往是由外部人员开发的，而且所占的比例可能要高于内部人员开发的技术。1977年，IBM公司内部肯定有一些部门正在开发下一代计算机。他们没有料到的是，真正的下一代计算机不是诞生于IBM实验室，而是由两个与他们完全不相干的长头发年轻人在旧金山的一间车库里开发出来的。这两个年轻人，一个是史蒂夫·乔布斯，另一个是史蒂夫·沃兹尼亚克4。

数据在本质上就是容易复制的。

黑客永远是自负的。

计算机确实是非常精确、有条不紊的，但是黑客的所作所为完全出于兴趣，想到哪里就做到哪里，没有明确的计划，只求开心。

很自负的人必须培养出敏锐的感觉，及时发现周围情势的变化，知道怎样才能脱身。


### 5 另一条路

网景公司于1995年8月9日上市，股票发行价格28美元一股，盘中最高价格为74.75美元，报收在58.25美元，涨幅高达108%左右。这直接促成了网络创业热，带动了雅虎、eBay和亚马逊的上市，开创了互联网公司的上市热潮。


#### 下一个潮流？

现在，可以有另一种方法发布软件，用户再也不会被迫当上系统管理员了。互联网软件运行在服务器上，用户界面就是网页。对于普通用户来说，这种新型软件将更容易、更便宜、更机动、更可靠，通常也比桌面软件更强大。


#### 用户的胜利

“你的计算机”这个概念正慢慢成为过去时，取而代之的是“你的数据”。你应该可以从任何计算机上获取你的数据，或者更准确地说，在任何终端设备上获取你的数据，终端设备不一定是计算机。


#### 代码之城

互联网软件与桌面软件最显著的区别就是，前者不是一个单独的代码块。它是许多不同种类程序的集合，而不是一个单独的巨大的二进制文件。设计桌面软件就像设计一幢大楼，而设计互联网软件就像设计一座城市：你不仅需要设计建筑物，还要设计道路、路标、公用设施、警察局和消防队，并且制定城市发展规划和紧急事件的应对方案。

可以在不关闭网站的情况下，将网上商店转移到另一个机房的服务器上。

向系统管理员发出传呼信号的程序，向用户发传真和电子邮件的程序，引导完成信用卡交易的程序，通过套接字、通信管路、HTTP请求、SSH、UDP数据包、共享内存和文件互相通信的程序。

保证Unix系统安全的关键之一就是不运行那些不需要的东西，以降低服务器被侵入的可能性。

硬件需要考虑的地方，不仅仅在于怎样才能避免出问题，还在于怎样才能最大化地发挥它们的作用。

只要你控制了硬件，就能为用户提供更多的功能。

如果你的产品是桌面软件，你就只能规定硬件的最低配置，无法为了某一个功能而要求用户增加硬件。但是，如果你控制了服务器，你就能轻而易举地增加功能

由于互联网应用程序由多种软件而不是单独一个二进制文件构成，所以可以使用多种编程语言开发。如果你的产品是桌面软件，一般来说，你总是被迫采用与操作系统一致的语言，也就是C和C++。所以，这些语言就被认为是“正统的”软件开发语言（非技术人员尤其可能这样想，比如经理层和风险投资家）。但是，这其实是一个伪信号（artifact）

CGI脚本不能识别用户状态


#### 软件的发布

互联网软件带来的最大变化之一，就是软件发布方式的改变。对于桌面软件来说，发布新版本是一个很痛苦的过程，整个公司不得不使尽全力，满头大汗地挤出一大块巨型代码。从过程和结果上来看，这无异于一次分娩。
互联网软件则完全不同，就像你写给自己用的程序一样，修改起来很方便。软件的发布过程可以分解为一系列的渐进式修改，而不是猛地推出一个大幅变动的版本。常见的桌面软件可能一年发布一到两个新版本，而我们在Viaweb经常是一天发布三到五个版本。

桌面软件开发之中的许多棘手问题，都源自它那种灾难性的发布方式。

对于互联网软件来说，大部分的变化是细微和渐进的，所以引入bug的机会比较小。而且，在发布前测试的时候，你知道应该最仔细地测试哪个部分——显然就是你修改过的部分。这使得你对代码的掌握变得牢固得多。

桌面软件导致了bug的宿命论。你很清楚，发布出去的软件肯定有bug，你甚至早就准备好了应对机制（比如发布补丁）。

苹果公司前几年就干过这种事。他们必须发布新版操作系统了，压力越来越大，发布日期已经推迟了4次，无法再推了，可是有些部分（比如CD和DVD操作的部分）还一点儿没写。怎么办？他们就把没写完的操作系统发布出去了，用户必须日后自己动手安装缺失的部分。

互联网软件的发布规则是：它运行不了，你就无法发布；一旦它能运行了，你就可以立刻发布。

事实上，你不会对互联网软件做出这样的承诺，因为它根本没有“版本”这个概念。你的软件是连续性渐变的，某些更新也许比较重大，但是“版本”这个概念不适用于互联网软件。


#### 软件bug

互联网软件的另一个技术优势在于，你能再现大部分的bug。用户的数据都在你的硬盘上。如果某个用户使用软件时出错了，你就不必像开发桌面软件那样苦苦猜测到底发生了什么事情。

互联网软件每时每刻都在被使用。你的代码一上线，就会经历严酷考验，bug很快就会浮出水面。

解决新代码的bug要比解决历史遗留代码的bug容易。

随着软件规模的增大，开发成本呈指数级上升。这可能是因为需要修正旧bug。如果bug都能被快速发现，成本的上升形态就能基本保持线性。

早一点发现bug就不容易形成复合式bug，也就是互相影响的两个bug。举例来说，一个bug是楼梯很滑，另一个bug是扶手松了，那么只有当这两个bug互相作用时，才会导致你从楼梯上摔下来。在软件中，复合式bug是最难发现的bug，往往也会导致最大的损失。

复合式bug有一个子类型：两个bug是互相弥补的，好比“负负得正”，软件反而能正常运行。这种bug可能才是最难发现的bug。当你修正了其中的一个bug，另一个bug才会暴露出来。这时你会觉得刚才修正错了，因为那是你最后修改的地方，你就怀疑自己在那里做错了，但是你其实是对的。

很难用纯粹的函数式编程完成整个程序，但是它可以用来编写一些重要的部分，使得这些部分易于调试，因为它们不包含“状态”，非常便于不断进行小幅的修改和测试。


#### 客户支持

我们在Viaweb举办过一个比赛，看谁能说出我们软件中最差劲的地方。


#### 全身心投入

步行上班途中，我经常会想哪些地方还需要变动，然后当天就予以实现。

如果软件的新版本要等到一年后才能发布，我就会把大部分新构思束之高阁，至少过上一段时间再来考虑。但是，构思这种东西有一个特点，那就是它会导致更多的构思。你有没有注意过，在坐下来写东西的时候，一半的构思是写作时产生的？软件也是这样。实现某个构思，会带来更多的构思。所以，将一个构思束之高阁，不仅意味着延迟它的实现，还意味着延迟所有在实现过程中激发的构思。

事实上，将一个构思束之高阁，甚至会限制新构思的产生，因为你看一眼堆放在一边还没有实现的构思，就会想“我已经为下一个版本准备了很多有待实现的新东西”，你就懒得再思考更多的新功能了。

大公司的做法不是立刻实现新功能，而是先为新功能做一个计划。

计划这个词，只是将构思束之高阁的另一种表达方式。只要想到好的构思，我们就会立刻着手实现。


#### 逆向的《人月神话》

在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。

开发互联网软件需要的程序员比较少。我曾在一家中等规模的桌面软件公司工作，那里的工程部规模就超过100人，但是其中只有13人负责产品开发，剩下的人负责软件发布、软件移植以及其他事情。开发互联网软件，你最多只需要那13个人，因为不存在软件发布、软件移植以及其他事情。　

Viaweb的开发者只有3个人10。我一直在不停地招聘，压力很大，因为我们要把公司卖掉。我们很清楚地知道，买家不愿花大价钱买下一个只有3个程序员的公司。（解决方法：雇更多的人，在公司内创设其他项目，让他们去做。）

向一个项目增加人手，往往会拖慢项目进程。随着参与人数的增加，人与人之间需要的沟通成本呈现指数级增长。人数越来越多，开会讨论各个部分如何协同工作所需的时间越来越长，无法预见的互相影响越来越大，产生的bug也越来越多。

人数越来越少，软件开发的效率将呈指数式上升。

如果要说有什么缺点，就是由于开发人员比较少，每个程序员都必须承担一点儿系统管理的责任。当你在服务器上发布软件时，必须有人监控服务器，但是由于人员太少，监控员只能由开发人员兼任。


#### 关注用户

互联网软件不仅把开发者与他的代码更紧密地联系在了一起，而且把开发者与他的用户也更紧密地联系在了一起。

软件应该做到用户认为它可以做到的事情。但是，你不知道用户到底怎么想，除非你亲眼看到他们如何使用你的软件。相信我，看到和看不到大不相同。

互联网软件能够让你前所未有地了解用户行为。你不必再人为挑选一个小型的用户样本，进行重点观察。每个用户的每一次点击你都可以看到。

你不得不仔细斟酌到底要看哪些行为，因为你不应该侵犯用户的隐私。

因为你能得到用户数据，所以就不用依赖基准测试11了。基准测试不过是在模拟用户，而你现在能看到真实的用户。

基准测试（benchmark test）指的是先设置一个基本的数据环境，测试应用程序的表现，然后把这个表现当作“基准”（benchmark），用来比较其他情况下应用程序的表现。

我研究了用户点击行为，发现在某一个地方，在线试用的用户会停止前进，改为点击浏览器的“后退”按钮（如果你写过互联网软件，会发现“后退”按钮是设计中最费脑筋的问题之一，很有意思）。所以，我就在那个地方加了一条提示，告诉用户已经接近终点了，提醒他们不要点击“后退”按钮。


#### 金钱问题

软件开发不是静态的，而是一个持续不断的动态过程。按照传统的软件销售模式，厂商每推出一个新版本，就会强迫现有用户重新出钱购买，然后安装升级，只有这样厂商才能持续不断地获得收入。我认为，如果公开收取软件的订阅费，而不是让用户购买软件的所有权，操作起来会更自然、更简便。 “订报纸模式”正是互联网软件天然的收费模式。

互联网软件不可能用自由软件的模式经营，只能由商业性公司来经营。因为经营互联网软件要承担很大的风险，会产生大量支出，所以没有人会免费做这件事情的。

对于软件公司来说，互联网软件是一个很理想的收入来源。你每个季度的销售额不是从零开始，而是拥有一个持续的现金流。因为互联网软件每时每刻都可以升级，所以你不用担心做错什么事。事实上，你不可能真的做错什么事，因为如果用户痛恨你对软件的修改，你马上就会知道。你也不会有坏账的烦恼，如果谁不付钱，你就停止对他的服务。此外，你也不可能遇到盗版问题。

一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。

只要有可能，商业性公司就会采用一种叫作“价格歧视”12的定价方法，也就是针对不同的客户给出不同的报价，使得利润最大化。

软件的边际成本接近于零。

盗版实质上是一种价格歧视，只不过针对的是最底层的消费者。我觉得，软件公司明白这个道理，所以故意对某些盗版行为睁一只眼闭一只眼。14由于互联网软件无法盗版，所以软件公司必须想出其他策略推广软件。

相比桌面软件，互联网软件卖得更好，因为它易于销售。

如果某样商品购买起来很困难，人们就会改变主意，放弃购买。反过来也成立，如果某样东西易于购买，你就会多买一点。自从有了亚马逊网上书店，我买的新书比什么时候都多。

要求用户做的事越多，你担的风险就越大。


#### 目标客户

Viaweb一开始就把个人和小企业当作目标客户。我认为这是互联网软件的通行规则。这些客户决策比较灵活，又需要低成本的新技术，所以他们更愿意尝试新事物。

最好的内部网（Intranet）就是互联网（Internet）。

如果你想把钱藏在安全的地方，请问你是选择放在家中床垫下面，还是放在银行？

不少公司很想知道，什么事情可以外包，什么事情不可以外包。一个可能的答案是，公司内部所有不直接感受到竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。（我这里所说的“外包”，指的是聘请另一个公司来执行，而不是指把业务部门转移到海外。）


#### 桌面电脑

我认为，许多人没有意识到最早的创业公司是多么脆弱和踌躇。许多创业公司的出现完全出于偶然。

如果你现在开发桌面软件，就不得不接受微软公司的授权条款，调用它的API，为它那个bug百出的操作系统伤透脑筋。历尽了千辛万苦，你最终写出了一个大受欢迎的软件，这时你可能会发现，你所做的一切其实只是在为微软公司做市场调查。

苹果公司同时做软件和硬件，所以成本上没有优势。（但是，苹果公司还没有失败，如果它能把iPod升级成手机，并且将网络浏览器包括在其中，那么微软公司就有大麻烦了。）（译者注：这段话写于2001年9月，苹果公司的iPhone手机已于2007年6月上市。）

有了互联网就可以绕过Windows，直接在Unix系统上发布软件，用户通过浏览器使用。这种趋势将会迅猛发展，很像20年前个人计算机刚刚诞生时的情景。


#### 微软公司

一个优秀的开源浏览器会帮到互联网软件，防止它们被微软扼杀。


#### 创业公司

你必须打破常规、快速行动，循规蹈矩不可能成功。

纵观创业公司的历史，你会发现它们变得越来越小，越来越快，越来越不像正规的企业。

帕金森定律是英国作家西里尔·诺斯古德·帕金森（Cyril Northcote Parkinson，1909—1993）在1955~1958年发表的一系列文章的总称。在这些文章中，帕金森讽刺了英国的官僚主义，总结了许多常见的官僚主义的表现形式。“帕金森定律”后来成为这些表现形式的代名词，它包括很多内容，其中有一条就是“因为你必须做到，所以你能够做到”

本文作者称“因为你能够做到，所以你必须做到”是逆向的帕金森定律。

互联网软件提供了一种天然的途径，使得你可以用较少的人力完成较多的工作，从而超过竞争对手。创业公司对这一点应该感到心满意足。

由于互联网软件的程序员非常辛苦，所以会使得经济优势根本性地从大公司向创业公司转移。互联网软件要求的那种工作强度和付出，只有当公司是其本人所有时，程序员才愿意承受。软件公司可以雇到能干的人，让他们去干轻松的事情，也可以雇到不能干的人，让他们去干艰苦的事情，但是无法雇到非常能干的人，让他们去干非常艰苦的事情。因为互联网软件的创业不需要太多的资本，所以大公司可以与创业公司竞争的优势就所剩无几了。


#### 勉强够用的网页

Altair 指的是MITS公司在1975年推出的Altair 8800微型计算机，CPU为Intel 8080。它是第一批微型计算机中最成功的产品，被认为是最早的个人计算机，上市第一个月就卖出了几千台。它所使用的总线，后来成为微机总线的第一个标准S-100，而微软公司的第一个产品就是为Altair开发的编程语言Altair Basic。

Edward Roberts（1941—2010），美国工程师。1970年创立MITS公司，1975年设计出了历史性的产品——微型计算机Altair 8800，开创了个人计算机的时代，后来被称为“个人计算机之父”。1977年，他卖掉了MITS公司，来到佐治亚州乡下研究医学，最后成为小镇上的医生。

互联网软件的开发成本低，即使是最小型的公司，也可以很容易地制作和发布。互联网软件做起来很辛苦，还有许多特别大的压力，但是这样只会使得创业公司成功的机会变大。


#### 为什么不尝试一下

E. B. 怀特26曾经从一个农民朋友那里听到一则趣闻。许多农场用电篱笆防止奶牛逃跑，但是不少电篱笆其实并没有通电。不过奶牛们已经吃过苦头，显然学会了不去碰电篱笆，这时不通电也能达到效果。“奶牛们，行动吧！”他写道，“趁着统治者打鼾时，夺回你们的自由！”

如果你是一个黑客，并且梦想自己创业，可能会有两件事情令你望而却步，不敢真正开始采取行动。一件是你不懂得管理企业，另一件是你害怕竞争。可是实际上，这两件事都是没有通电的电篱笆。

首先，管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。只要做到这两点，你就会超过大多数创业公司。随着事业的发展，你自己就能琢磨出来其他的诀窍。

从制造简洁的产品着手，首先要保证你自己愿意使用。然后，迅速地做出1.0版，并且不断加以改进，整个过程中密切倾听用户的反馈。用户总是对的，但是不同的用户要求不一样。低端的用户要求简化操作和清晰易懂，高端的用户要求你增加新功能。软件最大的好处就是让一切变得简单。

如果竞争对手的产品很糟糕，你也不要自鸣得意。比较软件的标准应该是看对手的软件将来会有什么功能，而不是现在有什么功能。


### 6 如何创造财富

如果你想致富，应该怎么做？我认为最好的办法就是自己创业，或者加入创业公司。


#### 一个命题

从经济学观点看，你可以把创业想象成一个压缩过程，你的所有工作年份被压缩成了短短几年。你不再是低强度地工作40年，而是以极限强度工作4年。在高技术领域，这种压缩的回报尤其丰厚，工作效率越高，额外报酬就越高。

如果你是一个20多岁的优秀黑客，每年的薪水大约是8万美元。这意味着，平均来看，你必须每年至少为公司带来8万美元利润，这样才能保证公司没有亏钱。但是，你真正的工作时间其实可以是公司上班时间的2倍，如果你全神贯注，每小时的产出可以提高3倍。1如果再把大公司里令人讨厌的中间管理层（他们经常以主管的身份妨碍你的工作）除去，你的效率可以再提高2倍。还有一个可以提高效率的地方：你不用再完成强行指派给你的工作，可以根据自己的愿望，做出最能发挥你聪明才智的成果。假定这会把工作效率再提高3倍。将这些因子放在一起做乘法，你的工作效率将是在公司时的36倍。2如果一个优秀黑客在大公司里的身价是每年8万美元，那么一个勤奋工作、摆脱杂事干扰的聪明黑客，他的工作相当于每年新创造约300万美元的价值。

往往只有在创业公司里，你才能得到一种宝贵的工作环境，就叫作“不受干扰”。

黑客要求的“不受干扰”的时间是非常长的，有时你用了1个小时才刚刚把一个问题理清，这时如果人事部突然打电话要你去填一张表格，就会造成巨大的成本损失。

这就是黑客往往在深夜工作的原因，也是黑客无法在小隔间里写出优秀软件的原因（除非在半夜）。

这里有一个守恒定律：如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦。


#### 金钱不等于财富

亚当·斯密在《国富论》中提到，许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是，黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。

交换媒介的优点是，它使得交易可以进行下去。缺点是，它往往模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种媒介，让大家可以更方便地获得自己想要的东西。大多数生意的目的是创造财富，做出人们真正需要的东西。5


#### 大饼谬论

大多数情况下，世界上可供交换的财富不是一个恒定不变的量。人类历史上的财富一直在不停地增长和毁灭（总体上看是净增长）。

如果在修理旧车的过程中，你对环境造成了一些微小的破坏，那么你可能使得每个人都变得更贫穷了一点。但是即使把环境的成本考虑在内，这依然不是一个零和游戏，依然存在财富的净增长。我们可以举出这样的例子，一台坏机器里有一个零件松了，你把零件拧紧，机器可以重新运作，那么你就没对环境造成任何破坏，并且创造了财富。


#### 手工艺人

最可能明白财富能被创造出来的人就是那些善于制作东西的人，也就是手工艺人。他们做出来的东西直接放在商店里卖。但是，随着工业化时代的来临，手工艺人越来越少。目前还存在的最大的手工艺人群体就是程序员。

我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。

一听到最富有的5%的人口占有全社会一半以上的财富，往往会认定这是不公平的。一个有经验的程序员很可能也认为这是不公平的，因为最顶尖的5%的程序员写出了全世界99%的优秀软件。

创造出来的财富不一定非要通过出售实现价值。至少直到最近，科学家一直在把他们创造的财富真正地捐献给社会。青霉素的发现使得我们所有人都变得更富有，因为从此我们死于细菌感染的可能性变小了。


#### 工作是什么

在工业化国家，一个人至少在二十多岁之前，总是从属于这样或那样的某个组织。经过这么多年，你已经习惯了自己属于这样一群人，早上全部起床，都来到同样几幢建筑物，开始做自己正常情况下没兴趣做的事情。

财富的一个重要元素就是地理位置。

许多人20岁出头时感到非常困惑和压抑。大学生活很有趣，可是已经过去了，上班的日子为什么会差别这么大？不要搞糊涂了，你现在已经从顾客变成了仆人。在这种新生活中获得乐趣是可能的。不过，你首先需要入门，门口的牌子上写着“闲人勿进”。这种转变是一种冲击，如果你不赶快意识到这一点，事情将变得更糟。

对于大多数人来说，最好的选择可能是为某个现存的公司打工。但是，理解这种行为的真正含义对你没有什么坏处。工作就是在一个组织中，与许多人共同合作，做出某种人们需要的东西。


#### 更努力地工作 :star:

大公司会使得每个员工的贡献平均化，这是一个问题。我觉得，大公司最大的困扰就是无法准确测量每个员工的贡献，大多数时候它只是在瞎猜。在大公司中，你只要一般性地努力工作，就能得到意料之中的薪水。你不能明显无能或懒惰，但是谁也没觉得你会把全部精力投入工作。

你在工作上投入的精力越多，就越能产生规模效应。在某些行业，那些真正拼命工作的员工能够创造出比普通员工多十倍甚至百倍的财富。

成立公司的目的不是奖励那些将全部精力投入工作的员工。你不能对老板说“我打算十倍努力地工作，请你把我的薪水也增加十倍吧”，因为公司已经假定你在全力工作了。但是，真正的问题实际上在于公司无法测量你的贡献。

销售员是一个例外。他们产生的收入很容易测量，他们的薪水往往是销售额的一个百分比。如果一个销售员想更努力地工作，他马上就可以这样做，并且自动按比例得到更多的报酬。

普通员工的表现往往很难测量，所以也没人要求他们做出突出表现。


#### 可测量性和可放大性 :star:

要致富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩应该是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。

单单具备可测量性是不够的。比如，血汗工厂的工人报酬是按照计件制计算的，这是一个只有可测量性、没有可放大性的例子。你的表现可以被测量，并且据此得到回报，但是你没有决策的权力。你能做的唯一决策就是以多快的速度完成工作。即使你做到最快，回报可能也只增加一两倍。

在电影中扮演主角就是一种同时具备可测量性和可放大性的工作。你的表现可以用电影的总收入测量，同时也决定了电影的成败，所以也就具备了可放大性。

CEO也是一种同时具备可测量性和可放大性的工作。公司的表现就是CEO的表现，所以它具备可测量性；CEO的决策决定了整个公司的方向，所以它具备可放大性。

任何一个通过自身努力而致富的个人，在他身上应该都能同时发现可测量性和可放大性。

有一个办法可以发现是否存在可放大性，那就是看失败的可能性。因为收入和风险是对称的，所以如果有巨大的获利可能，就必然存在巨大的失败可能。CEO、电影明星、基金经理和专业运动员的头顶都悬着一把“宝剑”，随时可能掉下来。一旦他们搞砸了，他们就完了。如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。

如果你想同时具备可测量性和可放大性，不一定非当上CEO或电影明星不可，你只需要成为某个攻克难题的小团体的一部分就可以了。


#### 小团队 = 可测量性 :star:

就算你无法测量每个员工的贡献，但是你可以得到近似值，那就是测量小团队的贡献。

公司越小，你就越能准确估计每个人的贡献。

只有表演或写作这样的特殊工作，你才会一个人单干。

你最好找出色的人合作，因为他们的工作和你的一起平均计算。

大公司就像巨型的古罗马战舰，1 000个划船手共同划桨，推动它前进。但是，两个因素使得它快不起来：一个因素是，每个划船手看不到自己更努力划桨有何不同；另一个因素是，1 000人的团队使得任何个人的努力都被大大地平均化了。

如果你从大船上挑选出10个最优秀的划船手，把他们组成一个团队，这时，10人小船的优势才会真正显示出来。小团队带来的各种额外激励会在他们身上体现得淋漓尽致。

乔布斯曾经说过，创业的成败取决于最早加入公司的那10个人。我基本同意这个观点，虽然我觉得真正决定成败的其实只是前5人。小团队的优势不在于它本身的小，而在于你可以选择成员。我们不需要小村庄的那种“小”，而需要全明星第一阵容的那种“小”。

一个非常能干而且在乎回报的人，通常在同类人组成的小团队中会有更出色的表现，自己也会感到更满意。


#### 高科技 = 可放大性 :star:

创业公司为每个人提供了一条途径，可以同时获得可测量性和可放大性。因为创业公司是小团队，所以具备可测量性。因为创业公司通过发明新技术盈利，所以具备可放大性。

餐馆煎鸡蛋，理发店剪头发，每次只能为一个顾客提供服务，但是如果你解决了一个热门的技术难题，别人都会使用你的解决方案。这就是可放大性。

小团队天生就适合解决技术难题。技术的发展是非常快的，今天很有价值的技术，几年后可能就会丧失价值。小团队在如今这个时代可谓如鱼得水，因为他们不受官僚主义和烦琐管理制度的拖累。而且，技术的突破往往来自非常规的方法，小团队就较少受到常规方法的约束。

大公司也能开发出新技术，就是开发得比较慢而已。大公司的规模决定了它们无法快速行动，也无法测量并奖励表现优异的员工。

在现实中，大公司开发出来的新技术只出现在那些需要大规模资本投入的领域，比如微处理器、电厂和大型民用飞机等，因为在这些领域内创业公司没有能力与之竞争。不过，即使在这些领域，大公司也还是依仗创业公司提供零部件和构思。

我认为，就算看上去与技术无关的商业类公司，其实也是解决技术问题的。比如，麦当劳是快餐连锁集团，它的发展依靠的就是设计出了一个快餐服务体系，可以复制到全世界每一个角落。每一家麦当劳连锁店都必须严格遵守操作规定，这使得它就像软件一样运作。所以，麦当劳其实也符合“一次开发，普遍适用”的模式。沃尔玛也是如此，它的创始人山姆·沃顿（Sam Walton）并不是因为经营零售业而致富，而是因为设计出了一种新型商店。

我们故意选择那些很困难的技术问题。假定软件有两个候选的新功能，它们创造的商业价值完全相同，那么我们总是选择较困难的那个功能。

创业公司就像游击队一样，喜欢选择不易生存的深山老林作为根据地，政府的正规军无法追到那种地方。

这不仅是创业公司运作的好方法，更是创业公司的本质。

风险投资人（Venture Capitalist，VC）知道这个道理，并为它起了一个名字——进入壁垒。

如果你有一个新点子，你去找风险投资人，问他是否投资，他首先就会问你几个问题，其中之一就是其他人复制你的模式是否很困难。也就是说，你为竞争对手设置的壁垒有多高。

设置“进入壁垒”的方法之一就是申请专利。但是，专利的保护程度可能不高，竞争对手通常能找到绕过专利的方法。如果找不到，它们可能就不找了，直接侵犯你的专利，等着你去起诉它们。大公司不害怕打官司，这对它们来说是家常便饭。它们很清楚，打官司的成本高昂又很费时。

技术的发明人往往很难确定，所以明确无误地确认只有一个发明人很难。

俗话说得好，最好的防御就是进攻。如果你开发出来的技术是竞争对手难以复制的，那就够了，你不需要依靠其他防御手段了。一开始就选择较难的问题，此后的各种决策都选择较难的那个选项。

和我的想法一致。要去做更难更正确的事。更难的事往往是更正确的事，但也不都全是。
总的来说，这也是很好的处事原则。如果你有两个选择，就选较难的那个。如果你要选择是坐在家里看电视，还是外出跑步，那就出去跑步吧。这个方法有效的原因可能是遇到一难一易的两个选择时，往往出于懒惰的缘故，你会选择较容易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果，这个方法只是迫使你接受这一点。

总的来说，这也是很好的处事原则。如果你有两个选择，就选较难的那个。


#### 潜规则

创业的付出与回报虽然总体上是成比例的，但是在个体上是不成比例的。我在前面说过，对于个人来说，付出与回报之间存在一个很随机的放大因子。你努力30倍，最后得到的回报在现实中并不是30倍，而是0到1 000倍之间的一个随机数。

大多数创业公司以失败告终，其中并不都是很烂的项目

保险的做法就是在早期卖掉自己的创业公司，放弃未来发展壮大（但风险也随之增大）的机会，只求数量较少但是更有把握的回报。

一家大到有能力收购其他公司的公司必然也是一家大到变得很保守的公司，而这些公司内部负责收购的人又比其他人更保守，因为他们多半是从商学院毕业的，没有经历过公司的创业期。他们宁愿花大钱做更安全的选择，所以向他们出售一家已经成功的创业公司要比出售还处在早期阶段的创业公司更容易，即使会让他们付出多得多的价码。


#### 用户数量

我认为，如果你的公司有机会被收购，那将是不错的选择。管理一家公司与创立一家公司是不同的两件事。当情况基本稳定下来以后，不妨让大公司来接手。这在财务上也是明智的选择，卖掉公司你的风险就分散了，这就好像有一个理财师建议你用所有钱投资一支波动性很大的股票，你会怎么想？

潜在的买家会尽可能地拖延收购。收购这件事最难的地方就是让买方真正拿出钱。大多数时候，促成买方掏钱的最好办法不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是让他们看到竞争对手可能收购你，我们发现这会使得CEO们连夜行动。次强的动机则是让他们担心如果现在不收购你，你的高速成长将使得未来的收购耗资巨大，甚至你本身可能变成他们的一个竞争对手。

在这两种收购动机中，归根结底的因素都是用户数量。

你以为买家在收购前会做很多研究，搞清楚你的公司到底值多少钱，其实根本不是这么回事，他们真正在意的只是你拥有的用户数量。

开办创业公司不是单纯地为了解决问题，而是为了解决那些用户关心的问题。

我认为你应该和买家一样，也把用户数量当作一个测试指标。像优化软件一样优化公司，用户数量就是判断公司表现好坏的指标。

用户数量也许不是最好的测量指标，但应该也相差不远了。

尽快拿出1.0版，然后根据用户的反映而不是自己的猜测优化软件。

你必须时刻牢记的最基本的原则就是，创造人们需要的东西，也就是创造财富。


#### 财富和权力

创造财富不是致富的唯一方法。在人类的历史长河中，它甚至不是最常见的方法。就在几个世纪前，财富的主要来源还是矿石、奴隶、农奴、土地和牲畜，而快速获得财富的方法只有继承、婚姻、征服和没收，所以很自然地，财富的名声不好。

在相当长的历史时期内，你的财富得不到保护，统治者和他的手下可以设法将它占为己有。

创造财富的人能够心安理得地享用自己的财富，这确实是工业革命的一个必要条件（可能不是充分条件）。

还记得从经济学观点看什么是创业公司吗？简单地说，就是可以让人更快速工作的地方。你不再是慢慢地积累50年的普通工资，而是要尽快地将这笔钱赚到手。

缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。

一旦自己的财产有了保证，那些想致富的人就会愿意去创造财富，而不是去偷窃。

要鼓励大家去创业，只要懂得藏富于民，国家就会变得强大。让“书呆子”保住他们的血汗钱，你就会无敌于天下。


### 7 关注贫富分化

我认为有三个原因使得我们对赚钱另眼相看：第一，我们从小对财富的看法是被误导的；第二，历史上积累财富的方式大多名声不好；第三，担心收入差距拉大将对社会产生不利影响。就我所知，第一点是错的，第二点已经过时了，第三点通不过现实的检验。有没有可能，在现代社会中，收入差距拉大实际上是一种健康的信号？


#### 财富的老爹模式

一个人的工作具有多少价值不是由政府决定的，而是由市场决定的。

我们把由父母供给收入的模式称为“老爹模式”。这个模式与真实世界的最大区别之一就是对勤奋工作的评价不同。在老爹模式中，勤奋工作本身就是值得的，老爹会感到很高兴。但是在现实中，财富是用工作成果衡量的，而不是用它花费的成本衡量的。

如果收入完全根据个人创造的财富数量而分配，那么结果可能是不平均的，但是很难说是不公平的。


#### 偷窃

很多人对贫富分化不满意的第二个原因就是，在大部分的人类历史中，积累财富最常见的方法其实是偷窃。

一旦通过创造财富而使致富成为可能，社会从整体上就会快速地变得更富有。

巴尔扎克说过：“每一笔巨大财富的背后，都隐藏着罪行。”这句话被广泛引用，但是他其实说的是另一个意思：如果巨大财富没有明显的来源，那可能就来源于精心安排的犯罪活动，由于掩盖得太好，使得罪行被人遗忘了


#### 技术的杠杆效应

无法被技术变得更便宜的唯一东西，就是品牌。这正是为什么我们现在越来越多地听到品牌这个词。富人与穷人之间生活的鸿沟正在缩小，品牌是这种差距的遗留物。

如果想要真正地对收入加以考察，你必须使用“实际收入”（以购买力衡量的收入）的概念，而不是使用“名义收入”（以货币衡量的收入）的概念。

如今，确实有很多人非常有钱，完全不必再去工作，他们之所以还在工作，不是因为感到社会压力，而是因为无所事事使人感到孤独和消沉。

今天的社会身份（social distinction）差异也要比100年前小得多。那时的小说和讲解礼仪的手册在今天读起来好像是在说陌生的部落社会。

今天的人们多多少少还是有一些互相隔离的趋势，但主要是因为教育层次的差别，而不是财富的差别。

技术在加大收入差距的同时，缩小了大部分其他差距。


#### 公理的不同意见

我想提出一种相反的观点：现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了；（b）那些创造大部分财富的人停止工作了；（c）创造财富的人没有获得报酬。

如果得不到报酬，人们是否愿意创造财富？唯一的可能就是，工作必须能提供乐趣。会有人愿意免费写一个操作系统，但是他们不愿意免费为你安装、提供电话支持、进行客户培训等。即使是最先进的高科技公司，也有至少90%的工作没有乐趣、令人生厌。

只要你压制收入差距的扩大，不管是用偷窃私人财产的做法（封建社会），还是用高额税收的做法（某些现代政府），最终结果看来都是一样的，那就是社会作为一个整体变得更贫穷了。

总的来说，你要避免的是绝对贫穷，而不是相对贫穷。如果必须在这两种社会之间做选择，根据目前的证据，我选择个人相对贫穷但是整体上更富裕的社会。

一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程中做出的事情。


### 8 防止垃圾邮件的一种方法

大多数黑客是好胜心很强的人，一般人往往意识不到这一点。

我在文章的开头说，我的过滤器现在可以在1 000封垃圾邮件中正确识别出995封，并且没有一个误判。做到这一点的前提是必须有一个很大的邮件库作为判断依据。

我提倡使用白名单，主要是为了减少计算，而不是认为这样可以改进过滤器的效果。我曾经认为白名单会让过滤器运作得更顺利，因为你从此只需要扫描那些陌生人的邮件就行了。


### 9 设计者的品味

数学家会用“优美的”来称赞出色的工作。无论古今，科学家、工程师、音乐家、建筑师、设计师、作家和画家都是这样做的，他们都使用同一个词。

好设计是简单的设计。从数学领域到绘画领域，你都可以听到这种说法。在数学中，它意味着简短的证明往往是更好的证明。

好设计是永不过时的设计。

只要没有错误，每一个数学证明都是永不过时的。所以，数学家哈代才会说：“丑陋的数学在世界上无法生存。”他的意思与飞机设计师凯利·约翰逊的观点是一样的：如果解决方法是丑陋的，那就肯定还有更好的解决方法，只是还没有发现而已。

以永不过时作为目标是一种帮助自己找到最佳答案的方法：如果你不愿别人的答案取代你的答案，你就只好自己给出最佳答案。

好设计是解决主要问题的设计。

好设计是启发性的设计。

在软件业中，这条原则意味着，你应该为用户提供一些基本模块，使得他们可以随心所欲地自由组合，就像玩乐高积木那样。

好设计通常是有点趣味性的设计。

因为幽默在一定程度上反映了力量。幽默感是强壮的一种表现，始终拥有幽默感就代表你对厄运一笑了之，而丧失幽默感则表示你被厄运深深伤到。

好设计是艰苦的设计。

好设计是看似容易的设计。

好设计是一种再设计。很少有人一次就把事情做对。专家的做法是先完成一个早期原型，然后提出修改计划，最后把早期原型扔掉。

犯错误是很正常的事情。你不要把犯错看成灾难，要勇于承认、勇于改正。

好设计是能够复制的设计。我们对待复制的态度经常是一个否定之否定的过程。刚入门的新手不知不觉地模仿他人，逐渐熟练之后才开始创作原创性作品。最后他会意识到，把事情做对比原创更重要。

等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。你的品味就进入了第二阶段，开始自觉地进行原创。

伟大的大师最终会达到一种超脱自我的境界。他们一心想找到正确答案，如果别人已经回答出了一部分，那就没理由不拿来用。他们足够自信地使用他人的成果，完全不担心因此丧失个人的特点。

好设计常常是奇特的设计。他只想找出真理，是真理本身显得很奇特。

好设计是成批出现的。

推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。互相激励比天赋更重要，达·芬奇之所以成为达·芬奇，主要原因不仅仅是他的天赋，更重要的是他生活在当时的佛罗伦萨，而不是米兰。

在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果。在某种程度上，你个人最多可以对趋势产生一定的影响，但是你不可能决定趋势，实际上是趋势决定了你。

设计常常是大胆的设计。在任何一段历史中，人们都会把某些荒谬的东西当作正确的，并且深信不疑，以至于一旦你出言质疑，就有被排挤或者被暴力伤害的危险。

我们自己的这个时代要是不同以往，当然令人欢欣鼓舞，但是就我所知，它并没有任何不同。

今天的实验性错误就是明天的新理论。

伟大成果的出现常常来源于某人看到一样东西后，心想我能做得比这更好。

做出优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。


## 第三部分 黑客的工具和工作方法

如果想在软件行业获得成功，就要毫不犹豫地选择最强大的编程语言。


### 10 编程语言解析


#### 机器语言

机器语言和汇编语言的共同问题就是，只能让大多数计算机做一些很简单的事情。

一个操作所需的代码越多，就越难避免bug，也越难发现它们。


#### 高级语言

程序员的助手不是一个人，而是编译器。所谓“编译器”，本身就是一个程序，作用是将以简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。

高级语言还有一个优点，它使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的，所以你无法将为某一种机型写的机器语言程序放到另一种机型上运行，只有彻底重写才能实现。但是，如果你的程序是用高级语言写的，你只需要重写编译器就可以了。

编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。


#### 开放源码

编译器处理的高级语言代码又叫作源码。它经过翻译以后产生的机器码就叫作目标码。

顾客购买市场上的商业软件时得到的往往只是目标码（目标码很难读懂，所以相当于被加密了，可以保护公司的商业秘密）。

后来出现另一种潮流：开放源码的软件。你可以得到源码，并且可以不受限制地修改它。

开放源码的优势还不仅局限于可以自己动手解决bug，这里的关键是所有人都可以参与。开源软件就像一篇经受同行评议的论文，许许多多的聪明人仔细阅读了Linux和FreeBSD这样的开源操作系统的源码，发现并且解决了大量的bug。

普通的消费者也许不需要看到他们使用的文字处理器的源码，但是在非常强调软件可靠性的情况下，出于强烈的工程需求的考虑，会要求开放源码。


#### 语言的战争

现在很少有人使用汇编语言。程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了，所以几乎不值得非常麻烦地用汇编语言开发软件。

只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观层面控制硬件，使得游戏速度得到最大限度的终极提高。

不同机器语言的指令集基本相同，但是高级语言就不一样，它们开发程序的模式差别相当大。

如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。

可能因为想炫耀自己见多识广，某些黑客会告诉你所有高级语言基本相似。“所有编程语言我都用过。”某个看上去饱经风霜又酷的黑客往酒吧里一坐，“你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。”
这当然是一派胡言。各种语言简直是天差地别，比如Fortran I和最新版的Perl就是两种完全不同的语言，而早期版的Perl和最新版的Perl之间的差别也大得惊人。

事实介于这两个极端之间。语言之间确实有差别，但是很难确定地说哪一种语言是最好的。这个领域依然还在快速发展。


#### 抽象性

C语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而Lisp语言的层次则是相当高。

会用到低层次语言的另一个原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。

硬件的运行速度越来越快了，所以使用C这样的低层次语言开发应用程序的必要性正在不断下降，但是大家似乎还是要求操作系统越快越好。

最常见的几种入侵计算机的手法都是利用了C语言的某些特点。


#### 安全带还是手铐

语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java语言是前一个阵营的代表，Perl语言则是后一个阵营的代表。（美国国防部很看中Java也就不足为奇了。）

在静态类型语言中，写代码时必须知道每个变量的类型。而在动态类型语言中，随便什么时候，你都可以把变量设为任意类型的值。

静态类型语言的拥护者认为这样可以防止bug，并且帮助编译器生成更快的代码（这两点理由都成立）。

动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。


#### 面向对象编程

面向对象编程的优点在于，如果你需要修改程序，计算另一种图形的面积，比如三角形，你只需要再另外增加一块相应的代码就可以了，甚至可以不修改程序的其他部分。

批评者会反驳说，这种方法的缺点是，由于增加代码不用考虑其他部分，结果往往导致写出性能不佳甚至有副作用的代码，

关于面向对象编程优劣的争论并不像静态类型语言与动态类型语言之争那样壁垒分明，因为编程的时候你只能在静态类型语言和动态类型语言之中选一种。但是，面向对象编程只是程度不同的问题。事实上有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程。

允许你做某事的语言肯定不差于强迫你做某事的语言，所以至少在这方面我们可以得到明确的结论：你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。


#### 文艺复兴

结果就是产生了一些也许可以称为“头重脚轻”的语言：它们的内核设计得并非很好，但是有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）

有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。

提醒各位亲爱的黑客，我只是打一个比方，请不要尝试在车顶绑上飞机发动机。另外，可以认为这类“头重脚轻”的语言存在已久，Fortran语言的流行主要就是因为它的函数库。

另一个结果就是语言的多样化。编程语言之间总是存在很大区别。Fortran、Lisp和APL都是1970年以前开发出来的，它们之间的区别大得就像海星、熊和蜻蜓之间的区别。

现在好像每隔一段日子就能听到一种新出现的语言。乔纳森·埃里克森把这种现象称为“编程语言的文艺复兴”。人们有时还会用另一个说法，即“编程语言的战争”。这并不矛盾，文艺复兴时期就是存在很多战争的。


### 11 一百年后的编程语言

这里的重点不是看衰Java，而是提出编程语言存在一个进化的脉络，从而引导读者思考，在整个进化过程中，某一种语言的位置到底在哪里？之所以要问这个问题，不是为了一百年后让后人感叹我们曾经如此英明，而是为了找到进化的主干。它会启发我们去选择那些靠近主干的语言，这样对当前的编程最有利。

Algol语言诞生于20世纪50年代，是最早的计算机语言之一，对后来的许多语言产生了极大的影响。

编程语言之所以可能出现聚合，一个原因是它的概率空间3比较小，另一个原因是它的突变不是随机的。语言的设计者们总是有意识地借鉴其他语言的设计思想。

概率空间是一个数学术语，大致指概率的可能取值范围。这里的意思是，不管编程语言怎么变，它的形式总是很有限的。

任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。

我认为，基本运算符是一种语言能否长期存在的最重要因素，其他因素都不是决定性的。这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置是没法变的。

慎重选择公理还不够，还必须控制它的规模。数学家总是觉得公理越少越好，我觉得他们说到了点子上。

在长期的职业生涯中，我发现冗余的代码会导致更多冗余的代码，不仅软件如此，对于像我这样性格懒散的人，我发现在床底下和房间的角落里这个命题也成立，一件垃圾会产生更多的垃圾。

我的判断是，那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。

软件发展的历史已经走过了五十年。在这五十年中，编程语言的进化其实是非常缓慢的

编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问题。所以，编程语言的进化速度更像数学符号的进化速度，而不像真正的技术（比如交通或通信技术）的进化速度。数学符号的进化是缓慢的渐变式变化，而不是像真正的技术那样跳跃式发展。

随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。

我记得当时使用的微机型号是TRS-80，它的内存只有4 KB，为了把BASIC程序装入内存，我不得不把源码中的空格全部删除。

对速度的追求是人类内心深处根深蒂固的欲望。当你看着计算机这个小玩意，就会不由自主地希望程序运行得越快越好，真的要下一番功夫才能把这种欲望克制住。在设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。

很多数据结构存在的原因都与计算机的速度有关。比如，今天的许多语言都同时有字符串和列表。从语义上看，字符串或多或少可以理解成列表的一个子集，其中的每一个元素都是字符。那么，为什么还需要把字符串单列为一种数据类型呢？完全可以不这么做。只是为了提高效率，所以字符串才会存在。但是，这种为了加快运行速度而使得编程语言的语义大大复杂的行为，很不可取。编程语言设置字符串似乎就是一个过早优化的例子。

正确做法应该是将语言的语义与语言的实现予以分离。在语义上不需要同时存在列表和字符串，单单列表就够了。而在实现上做好编译器优化，使它在必要时把字符串作为连续字节的形式处理。4

我相信，Lisp Machine Lisp（Lisp语言的一种方言）是第一个具体表达这样一种观点的语言：变量（除了动态类型变量之外）的声明只是优化的建议，对一个正确程序本身的含义不构成影响。Common Lisp（Lisp语言的另一种方言）则好像第一个明确提出了这一点。

对于大多数程序，速度不是最关键的因素，所以你通常不需要费心考虑这种硬件层面上的微观管理。随着计算机速度越来越快，这一点已经越发明显了。

当作者真正开始动手写这些软件的时候，他们其实不知道最后会写出什么结果。

Lisp语言的黑客早就明白数据结构灵活性的价值。我们写程序的第一版时，往往会把所有事情都用列表的形式处理。所以，这些最初版本可能效率低下得惊人，你必须努力克制自己才能忍住不动手优化它们

浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快，这会变得越来越明显。

数组会不会消失？毕竟数组只是散列表的一个子集，其特点就是数组的键全部都是整数向量。进一步说，散列表本身会不会被列表取代呢？

另一种消耗硬件性能的方法就是，在应用软件与硬件之间设置很多的软件层。这也是我们已经看到的一种趋势，许多新兴的语言就被编译成字节码5。

每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。

字节码（byte code）是已经经过编译但是需要进一步处理才能变成机器码的中间代码。它的好处是与硬件和软件环境无关，在编译器的配合下，可以在不同的操作系统上运行。字节码的典型运用就是Java语言。

即使是应用程序，使用多层形式开发也是一种很强大的技巧。自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性——的最佳路线。

可重用性这个概念多多少少与20世纪80年代兴起的面向对象编程有些关联。

某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它使用了面向对象编程，而是因为它的开发方法是自下而上的。

以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为它们采用面向对象编程或者其他编程方法。

我不认为面向对象编程将来会消亡。我觉得，除了某些特定的领域，这种编程方法其实没有为优秀程序员带来很多好处，但是它对大公司有不可抗拒的吸引力。面向对象编程使得你有办法对面条式代码进行可持续性开发。通过不断地打补丁，它让你将软件一步步做大。大公司总是倾向于采用这样的方式开发软件。我预计一百年后也是如此。

代码效率与机器性能的差距正在不断加大，我们将会越来越清楚地看到，应用软件运行速度提升的关键在于有一个好的性能分析器帮助指导程序开发。

过去10年最激动人心的趋势之一就是开源语言的崛起，比如Perl、Python和Ruby。语言设计已经被黑客接管。

在我看来，一种语言不支持宏，那就不值得使用了

新语言更多地以开源项目的形式出现，而不是以研究性项目的形式出现。这是语言的一种发展趋势。另一种发展趋势是，新语言的设计者更多的是本身就需要使用它们的应用软件作者，而不是编译器作者。这似乎是好的趋势，我期待它继续保持下去。

设计新语言的方法之一就是直接写下你想写的程序，不管编译器是否存在，也不管有没有支持它的硬件。这就是假设存在无限的资源供你支配。不管是今天还是一百年后，这样的假设好像都是有道理的。

但是事实上，我们的思想可能往往会受限于某种现存的语言，只采用在这种语言看来更简单的形式，它对我们思想的束缚作用会大得令人震惊。新语言必须靠你自己去发现，不能依靠那些让你自然而然就沉下去的思维定势。


### 12 拒绝平庸


#### 秘密武器

一般情况是，创业公司要么赢得一切，要么彻底失败。你要么成为富翁，要么一无所获。在创业的时候，如果你选择了错误的技术，竞争对手就会一举打败你。

在竞争中，你的对手无法理解你的技术优势，这可是再宝贵不过了。商场如战场，对手摸不透你，你的胜算就增加了。


#### Blub困境

编程语言的编程能力有差异。

如果你有好几种语言可以选择，在不考虑其他因素的情况下，你不选择最强大的那种语言就是一件很蠢的事。4

程序员关心的那种强大也许很难正式定义，但是有一个办法可以解释，那就是如果有一些功能在一种语言中是内置的，但是在另一种语言中需要修改解释器才能做到，那么前者就比后者更强大。

如果你的程序只是要做一些很简单的事（比如整数运算或者位操作），那就不妨使用一种比较靠近机器的低层次语言，主要原因是这样运行起来会更快一些。

到了一定年龄之后，程序员极少主动更换自己的编程语言。不管习惯使用的是哪一种语言，他们往往认为这种语言已经足够好了。

把宏说成一种独立的功能有误导之嫌。在实际运用中，如果没有其他Lisp功能（比如闭包和函数的rest参数）的配合，Lisp的宏也不会有太大作用。


#### 创业公司的合气道

因为编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。人类天性变化的速度远远慢于计算机硬件变化的速度，所以编程语言的发展通常比CPU的发展落后一二十年。

很多人对机器语言恋恋不舍，直到CPU开始采用精简指令集8了才不得不放弃使用机器语言。

精简指令集计算机（Reduced Instruction Set Computer，RISC）是CPU的一种架构，对指令数目和寻址方式都做了精简，使其实现更容易，执行速度更快，编译器的效率更高。它在20世纪80年代开始得到大规模采用。

技术的变化速度通常是很快的，但是编程语言不一样，与其说它是技术，还不如说是程序员的思考模式。编程语言是技术和宗教的混合物。9所以，一种很普通的编程语言就是很普通的程序员使用的语言，它的变化就像冰山那样缓慢。


### 13 书呆子的复仇

软件业有一场永不停息的战斗，书生气的开发者与官僚主义的经理之间总是发生冲突。

那些经理奇迹般地同时具备了两种很常见但很难结合在一起的特点：（a）对技术一无所知；（b）对技术有强烈的个人观点。

各种编程语言的编程能力是不相同的。

在某些情况下，一些语言就是比另一些语言更出色。

认为所有语言都一样的看法的缺点是自欺欺人，但是优点是可以使许多事情变得很简单。我想这就是这个看法被广泛接受的主要原因。这是一个令人舒服的想法。


#### 为什么Lisp语言很特别

按照被大众接受的程度，这9种思想依次如下排列。
（1） 条件结构（即if-then-else结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。
（2） 函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式，能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。
（3） 递归。Lisp是第一种支持递归函数的高级语言。
（4） 变量的动态类型。在Lisp语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。
（5） 垃圾回收机制。
（6） 程序由表达式组成。Lisp程序是一些表达式树的集合，每个表达式都返回一个值。这与Fortran和大多数后来的语言截然不同，它们的程序由表达式和语句组成。
区分表达式和语句在Fortran I中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。
后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从Fortran扩散到Algol语言，接着又扩散到它们两者的后继语言。
（7） 符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。
（8） 代码使用符号和常量组成的树形表示法。
（9） 无论什么时候，整个语言都是可用的。Lisp并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。
在读取期运行代码，使得用户可以重新调整Lisp的语法；在编译期运行代码，则是Lisp宏的工作基础；在运行期编译代码，使得Lisp可以在Emacs这样的程序中充当扩展语言；在运行期读取代码，使得程序之间可以用S表达式通信，近来XML格式的出现使得这个概念被重新“发明”出来了。4

随着时间流逝，流行的编程语言不断更新换代，语言设计思想逐渐向Lisp靠拢。思想（1）到思想（5）已经被广泛接受，思想（6）开始在主流编程语言中出现，思想（7）在Python语言中有所实现，不过似乎没有专用的语法。
思想（8）可能是最有意思的一点。它与思想（9）成为Lisp语言的一部分只是出于偶然，因为它们不属于麦卡锡的原始构想，是由拉塞尔自行添加的。它们从此使得Lisp语言看上去很古怪，但也成为了这种语言最独一无二的特点。

用一门语言自己的数据结构来表达该语言是非常有力量的。

思想（8）和思想（9）意味着你可以写出一种能够自己编程的程序。


#### 向心力

使用一种不常见的语言会出现的问题我想到了三个：你的程序可能无法很好地与使用其他语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。

到目前为止，大家公认少于10个人的团队最适合开发软件。雇用这样规模的开发团队，只要使用的不是无人知道的语言，应该都不会遇到很大麻烦。

事实上，选择更强大的编程语言会减少所需要的开发人员数量。

如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品，让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。如果没有用户，谁会关心你选择的“正统”技术是多么令人放心。


#### 附录：编程能力

所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言写出任何一个程序。那么，怎样才能做到这一点呢？就这个小小的例子而言，你只要使用这些不那么强大的语言写一个Lisp解释器就行了。

彼得·诺维格发现，总共23种设计模式之中，有16种在Lisp语言中“本身就提供，或者被大大简化”。


### 14 梦寐以求的编程语言


#### 外部因素

如果你想设计一种流行的编程语言，就不能只是单纯地设计语言本身，还必须为它找到一个依附的系统，而这个系统也必须流行。


#### 简洁

黑客欣赏的一个特点就是简洁。

黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。这个笑话其实与真实情况相差无几。就算这真的是个笑话，语言的设计者也必须把它当真，按照它的要求设计语言。

语言设计者应该总是看着代码，问自己能不能使用更少的语法单位把它表达出来。如果你有办法让许多不同的程序都能更简短地表达出来，那么这很可能意味着你发现了一种很有用的新抽象方法。

简洁性是静态类型语言力所不及之处。不考虑其他因素，没人愿意在程序的头部写上一大堆声明语句。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。


#### 可编程性

在选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。在编程语言的历史上，防止程序员做出“错误”举动的措施多得惊人。

语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。

你应该敞开胸怀，欢迎这种揣测。对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。

我经常觉得某个bug非常诱人，一定要追踪下去。不是程序员的人很难想象bug有什么好玩的。一切正常当然很好，但是不可否认，能够抓到某些bug会让人兴奋到极点。

一种真正优秀的编程语言应该既整洁又混乱。“整洁”的意思是设计得很清楚， 内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。“混乱”的意思是它允许黑客以自己的方式使用。C语言就是这样的例子


#### 一次性程序

一次性程序往往不是真的只用一次，就像第二次世界大战期间很多美国大学造的一大批临时建筑后来都成了永久建筑。许多一次性程序后来也都变成了正式的程序，具备了正式的功能和外部用户。
我有一种预感，最优秀的那些大型程序就是这样发展起来的，而不是像胡佛水坝那样从一开始就作为大型工程来设计。一下子从无到有做出一个大项目是很恐怖的一件事。

当人们接手一个巨型项目时，很容易被它搞得一蹶不振。最后，要么是项目陷入僵局，要么是做出来一个规模小、性能差的东西。


#### 函数库

我认为，未来50年中，编程语言的进步很大一部分与函数库有关。未来的函数库将像语言内核一样精心设计。优秀函数库的重要性将超过语言本身。某种语言到底是静态类型还是动态类型，是面向对象编程还是函数式编程，这些都不如函数库重要。


#### 效率

编程时提高代码运行速度的关键是使用好的性能分析器（profiler），而不是使用其他方法

语言设计者喜欢提高编译器的速度，认为这是对自己技术水平的考验，而最多只把性能分析器当作一个附送给使用者的赠品。但是在现实中，一个好的性能分析器对程序的帮助可能大于编译器的作用。这里又一次反映出语言设计者与用户之间发生了脱节，前者竭尽全力想要解决的问题其实方向不甚正确。

设法显示正在运行的程序的情况，这对互联网软件尤其重要，因为服务器上有很多程序同时运行，它们都需要你密切关注。自动运行的性能分析器用图形实时显示程序运行时的内存状况，甚至可以发出声音，表示出现了问题。

在出现问题时，声音是很好的提示。

现在有一些语言先编译成字节码，然后再由解释器执行，这样做主要是为了让代码容易移植到不同的操作系统，但是这也可以变成一项很有用的功能。让字节码成为语言的正式组成部分，允许程序员在瓶颈处内嵌字节码，这可能是一个不错的主意。然后，针对这部分字节码的优化也就变得可以移植了。

随着互联网软件的兴起，越来越多的程序主要不是受限于计算机的运算速度，而是受限于I/O速度。加快I/O速度将是很值得做的一件事。

帕金森定律4被证明与摩尔定律一样颠扑不破。软件不断膨胀，消耗光所有可以得到的资源。

帕金森定律的一种原始表达形式是“工作总是到最后一刻才会完成”，后来引申到计算机领域就变成了“数据总是会填满所有空间”，更一般性的总结则是“对一种资源的需求总是会消耗光这种资源的所有供应”。

编程语言在这方面也能发挥作用，对线程的良好支持将使得所有用户共享同一个内存堆。持久化对象和语言内核级别的延迟加载支持也有助于减少内存需求。


#### 时间

一种编程语言要想变得流行，最后一关就是要经受住时间的考验。没人想用一种会被淘汰的语言编程，这方面已经有很多前车之鉴了。

大多数黑客往往会等上几年，看看某一种新语言的势头，然后才真正考虑使用它。

虚拟现实建模语言VRML刚诞生时曾经轰动一时，但是我决定等到一两年后再去学习它，结果一两年后已经没有学习的必要了，因为市场已经把它遗忘了。

发明新事物的人必须有耐心，要长年累月不断地做市场推广，直到人们开始接受这种发明。

技术被市场接纳的方式有两种，一种是自然成长式，另一种是大爆炸式。

自然成长式的一个例子就是在车库里白手起家、自力更生的创业者。几个好朋友埋头工作，在外界毫不知晓的情况下开发出某种新技术。

大爆炸式的例子是有风险投资支持、在市场上大张旗鼓宣传的创业公司。他们急急忙忙地开发一个产品，在推向市场的时候大肆曝光，立刻就获得了一大批使用者（至少他们希望如此）。

最终来看，自然成长式会比大爆炸式产生更好的技术，能为创始人带来更多的财富。如果你研究一下目前的主流技术，就会发现大部分是源于自然成长式。

这种模式不仅存在于商业公司，还存在于科研活动中。

Multics操作系统和Ada语言是大爆炸式项目，现在都已经销声匿迹了，而它们的继承者Unix和C语言则是自然成长式项目。


#### 再设计

著名散文家E. B.怀特说过，“最好的文字来自不停的修改”。

设计一样东西，最重要的一点就是要经常“再设计”，编程尤其如此，再多的修改都不过分。

用户是一把双刃剑。他们推动语言的发展，但也使得你不敢对语言进行大规模改造。

一开始的时候要精心选择用户，避免使用者过快增长。

发展用户就像一种优化过程，明智的做法就是放慢速度。一般情况下，用户比较少意味着你任何时候都可以加大修改的力度。

让一个委员会负责设计语言是非常糟糕的主意。委员会只会做出恶劣的设计。但是我觉得，委员会最大的问题在于他们妨碍了“再设计”。在委员会的主持下，修改一种语言是非常麻烦的事，没有人愿意自讨苦吃。

就算委员会只有两个人，还是会妨碍“再设计”，典型例子就是软件内部的各个接口由不同的人负责。这时除非两个人都同意改变接口，否则接口就无法改变。因此现实中，尽管软件功能越来越强大，内部接口却往往一成不变，成为整个系统中拖后腿的部分。

一种可能的解决方法是，将软件内部的接口设计成垂直接口而不是水平接口。这意味着软件内部的模块是一个个垂直堆积起来的抽象层，层与层之间的接口完全由其中的一层控制。如果较高的一层使用了较低的一层定义的语言，那么接口就由较低的一层控制；如果较低的一层从属于较高的一层，那么接口就由较高的一层控制。


#### 梦寐以求的编程语言

黑客心目中梦寐以求的语言

语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。

这种语言的抽象程度很高，使得你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个真正出色的性能分析器，告诉你应该重点关注什么地方。你能让多重循环快得难以置信，并且在需要的地方还能直接嵌入字节码。

这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册，它本身很薄，里面关于限定条件和例外情况的警告寥寥无几。
这种语言的内核很小，但很强大。各个函数库高度独立，而且和内核一样经过精心设计，它们都能很好地协同工作。

这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。

除了一些绝对必要隐藏的东西，这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。事实上，它鼓励你参与它的设计，给你提供与语言创造者平等的权力。你能够对它的任何部分加以改变，甚至包括它的语法。它尽可能让你自己定义的部分与它本身定义的部分处于同等地位。这种梦幻般的编程语言不仅开放源码，更开放自身的设计。


### 15 设计与研究

做一个好的设计师就像做一个好医生一样。你不能头痛医头，脚痛医脚。病人告诉你症状，你必须找出他生病的真正原因，然后针对病因进行治疗。

除非设定目标用户，否则一种设计的好坏根本无从谈起。

怎么理解编程语言？你不要把它看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。

评价一种语言的优劣，不能简单地看最后的程序是否表达得很漂亮，而要看程序从无到有的那条完成路径是否很漂亮。

我们常常采用错误的方法评价编程语言，只看一眼最后完成的程序就做出判断。

“弱即是强”指的是一种软件传播的模式，由Common Lisp专家理查德·加布里埃尔（Richard P. Gabriel）于1991年在“Lisp: Good News, Bad News, How to Win Big”一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能（弱）反而是更好的选择（强），因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力。

这种模式在艺术领域普遍存在。

先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。在开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果，这好比让你看到不远处就是唾手可得的奖励，你因此会受到激励和鼓舞。

画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”


### 致谢

最后，我要感谢我的父母。父亲教给我什么是怀疑主义，母亲教给我如何发挥想象力。有了这样的母亲，我眼前的世界就从黑白变成了彩色。


### 术语表

Array　数组：一种存储数据的方式，教材中又称矩阵（matrix）

Bit Manipulation　位操作：对某个内存区域的一些简单的转换操作，比如在屏幕上移动窗口就可以通过位操作实现。

“自上而下编程”要求你把编程任务分解成一个个更小的单元，“自下而上编程法” 要求你先开发最底下的层，然后用底层所定义的“语言”开发上一层，这样直到最高层。这两种编程法可以结合使用。

Byte Code　字节码：类似于机器语言的计算机语言，但是不局限于特定的计算机。由于字节码与机器语言很类似，所以很容易开发出字节码解释器，让它把字节码转换成相应的机器语言命令。

Common Gateway Interface Script　CGI脚本/通用网关接口脚本：当网络服务器需要进行某种运算（比如数据库搜索）而不是直接传输现有文件时所运行的一种程序。CGI脚本的主要缺点是，每次运行只能生成一个页面，无法像桌面软件那样将数据保存在内存中从而实现与用户不间断的对话。

Complexity　复杂度：算法的“时间复杂度”（time complexity）指的是，当输入的数据量不断增加时，计算机完成这种算法所消耗的时间。比如，你要在一间屋子中寻找某一个人，方法是看每个人的脸，那么找到这个人所需要的时间与屋中的人数成正比。这样一种算法的时间复杂度就是O(n)，意为所需的时间与n成比例（n代表数据量）。现在进一步假设你要在屋子中寻找看上去长得很像的两兄弟（或两姐妹），那么你所需要的时间可能与人数的平方成正比，因为你也许不得不每两个人就比较一次，而所有可能的两人组合是人数的平方，时间复杂度就是O(n2)。

Hash Table　散列表：一种类似数据库的数据结构，存储在里面的每一段数据都有一个对应的键，使用时可以按照键取出对应的数据。

对于大多数语言来说，缩进只是让代码可读性更好。但是，对于另一些语言（比如Python），缩进有着特别重大的意义，会影响程序的行为。

Inner Loop　内循环：一个程序中执行次数最频繁的部分。

Instrument　记录仪：修改程序使得它的每一步结果都得到记录，这样的话，如果程序运行速度缓慢或者占用太多内存，你就能找到原因。

Legacy Software　历史遗留软件：这些软件虽然还有人使用，但是并不符合使用者的要求。

Lexical Closure　闭包：一个函数，通过它可以引用由包含这个函数的代码所定义的变量。

Linux：Unix操作系统的一个开源版本。讲究一点的话，它应该被称为GNU Iinux，因为它的内核部分是由林纳斯·托瓦兹（linus Torvalds）编写的，但是其他更大量的代码来自理查德·斯托曼（Richard Stallman）的GNU项目。

Occam's Razor　“奥卡姆剃刀”原则：简单的解释就是较好的解释。

Orthogonal　正交的：彼此独立、能够以多种方式组合在一起的一组东西。经典的乐高积木就比普通的塑料模型玩具更有正交性。

Pointer Arithmetic　指针运算：通过对已知地址进行加法运算在内存中找到目标对象。这是低层次语言的一种技巧。

Premature Design　过早设计：过早决定一个程序的行为。

Premature Optimization　过早优化：还没有写完程序，你就开始考虑它的性能问题。这样的软件好比姑娘还没有成年却已经嫁人了。

Statement　语句：一串不产生值的代码。

Subroutine　子程序：一块独立于其他代码的代码。

Syntax　句法：表达程序目的的形式。

Turing-Complete　图灵完备：如果一种编程语言写出的所有程序都能被转换成图灵机程序，并且反之也成立，那么这种编程语言就是图灵完备的。所有当代编程语言都是图灵完备的，这意味着（在理论上）它们的功能都是一样强大的。图灵完备又称图灵等价（Turing-Equivalent）。

