# 列表生成式

## 列表生成式 List Comprehensions 是什么

列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 `list` 的生成式。

### 用 `list(range(a, b))` 和循环

要生成 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` 列表可以用 `list(range(1, 11))`：

```python
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

如果我们要生成更复杂的 `[1x1, 2x2, 3x3, ..., 10x10]` 就需要用循化来完成。

```python
>>> L = []
>>> for x in range(1, 11):
...    L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

但是循环太繁琐了。

列表生成式可以一行语句代替上面的循化。

### 列表生成式

```python
# 生成 [1x1, 2x2, 3x3, ..., 10x10]
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

把要生成的元素 `x * x` 放到前面，后面跟 `for` 循环和条件判断，就可以把 `list` 创建出来。

`for` 循环后面还可以加上 `if` 判断，这样我们就可以筛选出仅偶数的平方：

列表生成式的语法可以拆分成几个部分 `[元素 + for 循环 + if 条件]`。

```python
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

### 双层 for 循环的列表生成式

还可以使用两层循环，可以生成全排列：

```python
>>> [m + n for m in 'ABC' for n in 'ZXY']
['AZ', 'AX', 'AY', 'BZ', 'BX', 'BY', 'CZ', 'CX', 'CY']
```

> 三层和三层以上的循环就很少用到了。

运用列表生成式，可以写出非常简洁的代码。

```python
# 列出当前目录下的所有文件和目录名，可以通过一行代码实现
>>> import os
>>> [d for d in os.listdir('.')]
```

### for 循化中使用两个变量

列表生成式也可以像 `for` 循化一样，使用两个变量来生成 `list`：

```python
>>> d = {'x': 'A', 'y': 'B', 'z': 'C'}
>>> [x + '=' + y for x, y in d.items()]
['x=A', 'y=B', 'z=C']
```

最后把一个 `list` 中所有的字符串变成小写：

```python
>>> L = ['Rust', 'Golang', 'C++', 'JavaScript']
>>> [x.lower() for x in L]
['rust', 'golang', 'c++', 'javascript']
```

### 使用条件判断

使用列表生成式的时候，也可以使用 `if ... else`。

以下代码正常输出偶数：

```python
>>> [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
```

因为 `for` 后面的 `if` 只是一个筛选条件，所以其后不能用 `else`。

而如果 `if` 写在 `for` 前面，就必须要加上 `else`。

```python
>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
```

这是因为条件判断在 `for` 前面是一个表达式，它必须根据 `x` 计算出一个结果。

> 在一个列表生成式中，`for` 前面的 `if ... else` 是表达式，必须带 `else`。
> 而后面的 `if` 是过滤条件，不能带 `else`。
