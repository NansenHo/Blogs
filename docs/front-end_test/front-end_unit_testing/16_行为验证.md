# 行为验证

## 什么是行为验证

行为验证：验证对象之间的交互是否按照预期执行。

对象间的交互：调用函数和调用对象的方法。

行为验证的背后逻辑是：

    状态的改变是由特定行为导致的。

    所以如果我们所有的行为都是正确的，那就可以推断出状态也是正确的。

## 如何获取交互信息

行为验证需要知道一些交互信息，比如

- 函数是否被调用

- 函数的参数是什么

- 函数被调用了几次

- ...

我们需要用 mock 来处理。

### mock 和 stub 的区别

> 这里的 mock 是指一种**测试替身**。
>
> stub 也是一种测试替身，但其职责和 mock 不同。
>
> 测试替身有很多种，不同职责的测试替身，有不同的名字。
>
> 现在测试替身中，基本上只有 mock 和 stub 仍在被广泛使用。

stub 是一种控制间接输入的方式，替换掉了间接输入的真实的实现逻辑。

而 mock 在 stub 的基础上，还增加了

1. 记录交互的信息

2. 可以基于交互信息，进行验证

代码示例：

stub 只用返回一个值即可。

```js
// stub
vi.mock("packageName", () => {
  return {
    functionName: () => 2,
  };
});
```

mock 在 stub 的基础上，还要记录交互信息。

```js
// mock
vi.mock("packageName", () => {
  return {
    functionName: vi.fn(() => 2),
  };
});
```

## 处理第三方库

比如，我们通过调用第三方库实现了一个登录逻辑。

这样我们就拿不到最终的状态，只能去验证其行为。

```js
vi.mock("hns", () => {
  return {
    login: vi.fn(),
  };
});

describe("login", () => {
  it("login function should be called from hns module", async () => {
    login("username", "password");

    // 验证被调用
    expect(login).toBeCalled();
    // 验证参数
    expect(login).toBeCalledWith("username", "password");
    // 验证被调用几次
    expect(login).toBeCalledTimes(1);
  });
});
```

但一般是在验证完行为后，仍然要验证状态。

比如在该例子中，我们就应该再接着验证 `loginState` 登录状态。

## 行为验证的缺点

1. 破坏了封装性

   行为验证是白盒测试，暴露了内部代码的实现细节。

   如果之后重构了代码，单元测试中的行为验证也需要维护。

2. 丧失了测试的有效性

   由于我们只是假定了执行完某个交互后，状态是正确的。

   比如在上面例子中，就是假定了 `login` 函数被执行后，就登录成功了。

   这样即使 `login` 函数的内部实现出现了错误，这个行为测试也仍然会通过，这样就丧失了测试的有效性。

> 由于使用了 mock，有时会出现测试通过了，但实际功能有问题的情况。

> 尽量采用状态验证，只有在**找不到状态来验证**，或者**状态非常难获取**的时候，才采用行为测试。
>
> 比如，调用了一个后端 API，但该 API 不会返回任何值。
>
> 比如，我们要验证数据是否被存入数据库的话，采用状态验证，就需要去访问数据库。
> 为了节省反复访问数据库带来的**时间成本**，可以改成用行为验证。
> 在该例子中，就可以看是否调用了数据库的保存操作。
