# 程序的间接输入

## 什么是直接输入

即业务代码里的函数**直接通过参数传入的形式**，去接受数据进行计算。

然后我们调用函数，传入参数即可。

这种方式就是直接输入。

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

## 什么是间接输入

像下面的代码一样，**通过其他模块/函数获取数据**，再进行计算，叫做间接输入。

```ts
export function doubleUserAge(): number {
  return userAge() * 2; // 通过 userAge 获得数据
}
```

## stub 存根：控制间接输入的值

`userAge` 可能是通过请求 API 或者读取 `store` 里的数据来获取的。

`age` 是一个很可能变化的值。

所以我们不能在测试里这样写死，一旦 `age` 改变了，测试就又需要维护。

```js
const doubleAge = doubleUserAge();
expect(doubleAge).toBe(50);
```

这种测试就是脆弱的测试。

我们想测的实际上是 `* 2` 的这个逻辑。

这样就需要去控制 `userAge` 的值。

很多测试框架都提供了**修改模块内部值**的能力。

stub 就是替换掉真实的逻辑实现，`vi.mock` 函数就是 Vitest 提供的 stub 实现。

`vi.mock` 的第二个参数是一个工厂函数。

```js
import { vi, it, expect } from vitest

// 自动提升
console.log(userAge()) // 2

vi.mock('./user', () => {
  return {
    userAge: () => 2, // 使用 userAge 替换掉了真实的 userAge 函数实现
  }
})

it('* 2', () => {
  const r = doubleUserAge()
  expect(r).toBe(4)
})

it('other', () => {
  // 全局生效
  console.log(userAge()); // 2
})
```

`vi.mock` 替换掉的东西会在该测试文件范围内，全局生效。

而且 `vi.mock` 会被自动提升到代码顶部。

### 避免提升到顶部

以下两种办法都能避免被替换掉的东西在测试文件范围内全局生效，以及自动提升到代码顶部。

选择哪个看喜欢的代码风格即可。

#### `vi.mocked().mockReturnValue()`

`vi.mock()` 也可以只接受一个 `path`，之后再进行 `mock`。

```js
import { userAge } from "./user";

// highlight-next-line
vi.mock("./user");

describe("控制间接输入的值", () => {
  it("* 2", () => {
    // highlight-next-line
    vi.mocked(userAge).mockReturnValue(2);

    const r = doubleUserAge();
    expect(r).toBe(4);
  });
});
```

这种方式允许我们在不同的测试 Case 里 `mock` 不同的值。

#### `vi.doMock()`

[`vi.doMock()` 官方文档](https://vitest.dev/api/vi.html#vi-domock)

```js
describe("控制间接输入的值", () => {
  beforeEach(() => {
    // highlight-start
    vi.doMock("./user", () => {
      return {
        userAge: () => 2,
      };
    });
    // highlight-end
  });

  it("* 2", async () => {
    // highlight-next-line
    const { doubleUserAge } = await import("./index");

    const r = doubleUserAge();
    expect(r).toBe(4);
  });
});
```

`vi.doMock()` 经常和 `beforeEach` 结合使用。

### 异步获取数据

以上的处理都是同步获取数据的处理，现在来了解异步获取数据的处理。

```js
// userAge.spec.ts
vi.mock("./user", () => {
  return {
    fetchUserAge: () => Promise.resolve(2),
  };
});

describe("控制间接输入的值", () => {
  it("* 2", async () => {
    const r = await fetchDoubleUserAge();
    expect(r).toBe(4);
  });
});
```

```ts
// userAge.ts
export async function fetchDoubleUserAge(): Promise<number> {
  const userAge = await fetchUserAge();
  return userAge * 2;
}
```

```ts
// api.ts
export function fetchUserAge(): Promise<number> {
  return new Promise((resolve, reject) => {
    setTimeOut(() => {
      return resolve(18);
    }, 0);
  });
}
```
