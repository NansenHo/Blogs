# 依赖函数的调用

## 什么是 `stub` 存根

`userAge` 可能是通过请求 API 或者读取 `store` 里的数据来获取的。

`age` 是一个很可能变化的值。

所以我们不能在测试里这样写死，一旦 `age` 改变了，测试就又需要维护。

```js
const doubleAge = doubleUserAge();
expect(doubleAge).toBe(50);
```

这种测试就是脆弱的测试。

我们想测的实际上是 `* 2` 的这个逻辑。

这样就需要去控制 `userAge` 的值。

stub 就是替换掉真实的逻辑实现。

## `vi.mock`

很多测试框架都提供了**修改模块内部值**的能力。

`vi.mock` 函数就是 Vitest 提供的 stub 实现。

`vi.mock` 的第一个参数是路径/模块名，第二个参数是一个工厂函数。

```js
import { vi, it, expect } from vitest

// 自动提升
console.log(userAge()) // 2

// highlight-start
vi.mock('./user', () => {
  return {
    userAge: () => 2, // 使用 userAge 替换掉了真实的 userAge 函数实现
  }
})
// highlight-end

it('* 2', () => {
  const r = doubleUserAge()
  expect(r).toBe(4)
})

it('other', () => {
  // 全局生效
  console.log(userAge()); // 2
})
```

`vi.mock` 替换掉的东西会在该测试文件范围内，全局生效。

而且 `vi.mock` 会被自动提升到代码顶部。

### 避免提升到顶部

以下两种办法都能避免被替换掉的东西在测试文件范围内全局生效，以及自动提升到代码顶部。

选择哪个看喜欢的代码风格即可。

#### `vi.mocked().mockReturnValue()`

`vi.mock()` 也可以只接受一个 `path`，之后再进行 `mock`。

```js
import { userAge } from "./user";

// highlight-next-line
vi.mock("./user");

describe("控制间接输入的值", () => {
  it("* 2", () => {
    // highlight-next-line
    vi.mocked(userAge).mockReturnValue(2);

    const r = doubleUserAge();
    expect(r).toBe(4);
  });
});
```

这种方式允许我们在不同的测试 Case 里 `mock` 不同的值。

#### `vi.doMock`

[`vi.doMock()` 官方文档](https://vitest.dev/api/vi.html#vi-domock)

```js
describe("控制间接输入的值", () => {
  beforeEach(() => {
    // highlight-start
    vi.doMock("./user", () => {
      return {
        userAge: () => 2,
      };
    });
    // highlight-end
  });

  it("* 2", async () => {
    // highlight-next-line
    const { doubleUserAge } = await import("./index");

    const r = doubleUserAge();
    expect(r).toBe(4);
  });
});
```

`vi.doMock()` 经常和 `beforeEach` 结合使用。

### 异步获取数据

以上的处理都是同步获取数据的处理，现在来了解异步获取数据的处理。

```js
// userAge.spec.ts
vi.mock("./user", () => {
  return {
    fetchUserAge: () => Promise.resolve(2),
  };
});

describe("控制间接输入的值", () => {
  it("* 2", async () => {
    const r = await fetchDoubleUserAge();
    expect(r).toBe(4);
  });
});
```

```ts
// userAge.ts
export async function fetchDoubleUserAge(): Promise<number> {
  const userAge = await fetchUserAge();
  return userAge * 2;
}
```

```ts
// api.ts
export function fetchUserAge(): Promise<number> {
  return new Promise((resolve, reject) => {
    setTimeOut(() => {
      return resolve(18);
    }, 0);
  });
}
```

## 通过第三方库/模块间接输入

如果调用了第三方模块，比如 Axios，那应该如何测试？

`mock` 第三方库/模块的函数，和我们 `mock` 自己写的函数是一样的，

唯一的区别只是，将**路径**改成了**模块名**。

```ts
import axios from "axios";

interface User {
  name: string;
  age: number;
}

export async function doubleUserAge() {
  const user: User = await axios("/user/1");
  return user.age * 2;
}
```

```ts
// highlight-next-line
vi.mock("axios");

test("第三方库/模块: Axios", async () => {
  // highlight-next-line
  vi.mocked(axios).mockResolveValue({ name: "nansen", age: 2 });

  const r = await doubleUserAge();
  expect(r).toBe(4);
});
```

如果使用的不是 `axios('/user/1')` 而是 `axios.get('/user/1')`，那只需要改为 `vi.mock(axios.get)` 即可。

## 通过对象间接输入

项目中，全局的配置对象是非常常见的。

比如下面代码读取了全局配置对象上的属性来进行相应输出。

```ts
// config.js
export const config = {
  allowTellAge: true,
  age: 18,
  getAge() {
    return 18;
  },
};
```

```ts
import { config } from "./config";

export function tellAge() {
  if (config.allowTellAge) {
    return 18;
  }
  return "就不告诉你";
}

export function isLegalAdult() {
  return config.getAge() > 18 ? "Yes" : "No";
}
```

如果要测试 `tellAge`，其使用了 `config` 里面的属性，可以直接修改 `config` 里面的属性值来测试不同的情况。

如果使用了 `config` 里面的方法，比如测试 `isLegalAdult`，做法也是一样，修改方法即可：

```ts
describe("通过对象间接输入", () => {
  it("属性", () => {
    config.allowTellAge = false;
    const r = tellAge();
    expect(r).toBe("就不告诉你");
  });

  it("方法", () => {
    config.getAge = () => {
      return 2;
    };

    const r = isLegalAdult();

    expect(r).toBe("No");
  });
});
```

## 通过 `class` 间接输入

```ts
export function doubleUserAge(): number {
  const user = new User();
  return user.age * 2;
}
```

```ts
vi.mock("./user");
```
