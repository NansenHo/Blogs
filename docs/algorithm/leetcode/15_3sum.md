# 15. 3 Sum | Medium

如果暴力求解，使用三层 `for` 循环，最后的时间复杂度会是 $O(n^3)$ 。

对于这种无序的数组，我们首先要考虑**将其排序是否会降低复杂度**。

## 排序 + 双指针查找

```js
var threeSum = function (nums) {
  if (nums.length < 3) {
    return [];
  }

  let list = [];
  let left, right;

  nums.sort((a, b) => a - b);

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) {
      continue;
    }

    left = i + 1;
    right = nums.length - 1;

    while (left < right) {
      if (right === i) {
        right--;
      } else if (nums[i] + nums[left] + nums[right] === 0) {
        list.push([nums[i], nums[left], nums[right]]);
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
      } else if (nums[i] + nums[left] + nums[right] > 0) {
        right--;
      } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++;
      }
    }
  }

  return list;
};

// TEST
console.log(threeSum([1, 2, 3]));
console.log(threeSum([1, 2]));
console.log(threeSum([-1, 0, 1, 2, -1, -4]));
console.log(threeSum([-2, 0, 3, -1, 4, 0, 3, 4, 1, 1, 1, -3, -5, 4, 0]));
```

### 为什么 `left` 不是 `0` 而是 `i + 1`

1. **避免重复**

   由于外部循环的 `i` 已经考虑了在 `i` 之前的所有元素与当前元素 `nums[i]` 的组合。

   所以如果我们将 `left` 初始为 `0`，会导致相同组合被重复考虑，且重复的组合也会出现在最终的结果中。

2. **优化性能**

   这样做，我们每一次循环都只需要考虑 `nums[i + 1]` 后面的元素组合。

   每次循环时都会减少检查的范围，从而提高算法的性能。

这样做既确保了每个可能的三元组仅被考虑一次，避免错误；也减少了重复计算，从而优化了性能。

### 为什么这种解法的复杂度是 $O(n^2)$

1. **外部的 `for` 循环**

   这个明显是一个 $O(n^2)$ 复杂度。

   因为它遍历了整个数组一次。

2. **内部的两个 `while` 循环**

   这两个 `while` 循环目的是增加或减少 `left` 和 `right` 指针的。

   它们是有顺序且非嵌套的。

   在最坏的情况下，
   `left` 从 `i + 1` 移动到数组的末尾，
   而 `right` 从数组的末尾移动到 `i + 1`。
   那这样，在这次 `for` 循环中，这两个指针加在一起，总共只会遍历数组一次。

   所以这两个 `while` 循环合起来是 $O(n)$。

### 去重处理

如果不对 `i`, `left` 和 `right` 三个指针进行去重，会有重复的结果被返回。

`left` 和 `right` 需要使用 `while` 来去重，因为可能有不止两个连续重复的数字。

`i` 在 `for` 循环中被逐个遍历，可以只检测是否和上一个值相同。

### 什么情况下 `right === i`

理论上，在正常的双指针操作中，这种情况是不应该发生的。

因为在这个算法中，`left` 指针初始化为 `i + 1`，而 `right` 指针初始化为数组的最后一个元素的索引 `nums.length - 1`。

由于 `i` 是从 0 开始遍历的，所以在正常情况下 `left` 总是在 `i` 的右侧，而 `right` 则在数组的末尾。

而且当 `right` 在 `left` 左侧或者和 `left` 在同一位置时，不会进入循环，直接返回 `list`。

所以正常情况下，`right === i` 是不会发生的。

但是以防出现意外，我们可以采用**防御性编程策略**，

加上对 `right === i` 的判断，来确保 `right` 指针不会意外地和 `i` 重合。
