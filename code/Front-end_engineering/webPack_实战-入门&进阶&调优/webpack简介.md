#  Webpack 实战：入门、进阶与调优（第2版）

居玉皓

- [Webpack 实战：入门、进阶与调优（第2版）](#webpack-实战入门进阶与调优第2版)
  - [第一章：Webpack  简介](#第一章webpack--简介)
    - [1.1 何为 Webpack](#11-何为-webpack)
    - [1.2 为什么需要 Webpack](#12-为什么需要-webpack)
    - [1.3 安装](#13-安装)
    - [1.4 打包第一个应用](#14-打包第一个应用)

##  第一章：Webpack  简介

### 1.1 何为 Webpack 

>  Webpack 是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。这个过程就叫作模块打包。

> 把 Webpack 理解为一个模块处理工厂。我们把源代码交给 Webpack ，由它去进行加工、拼装处理，产出最终的资源文件，等待送往用户。

> 在Web开发中与我们打交道的无非是HTML、CSS、JS等静态资源，为什么不直接将工程中的源文件发布到服务器或CDN，而要交给 Webpack 处理呢？这两者之间有什么不同？


### 1.2 为什么需要 Webpack 

> 在设计程序结构时，把所有代码都堆到一起是非常糟糕的做法。更好的组织方式是**按照特定的功能将其拆分为多个代码段，每个代码段实现一个特定的目的**。你**可以对其进行独立的设计、开发和测试**，最终**通过接口来将它们组合在一起**。这就是**基本的模块化思想**。

> 在过去的很长一段时间里，JavaScript 这门语言并没有模块这一概念。如果工程中有多个 JS 文件，我们只能通过 script 标签将它们一个个插入页面中。

> 引入多个 script 文件到页面中逐渐成为一种常态，但我们发现这种做法有很多缺点。
> - **需要手动维护 JavaScript 的加载顺序**。
> 页面的多个 script 之间通常会有依赖关系，但由于这种依赖关系是隐式的，除了添加注释以外很难清晰地指明谁依赖了谁，所以当页面中加载的文件过多时很容易出现问题。
> - 每一个 script 标签都意味着需要向服务器请求一次静态资源，在 HTTP2 还没有出现的时期，建立连接的成本是很高的，**过多的请求会严重拖慢网页的渲染速度**。
> - 在每个 script 标签中，顶层作用域即全局作用域，没有任何处理而直接在代码中进行变量或函数声明会**污染全局作用域**。

> ES6 模块化的优点：
> - 通过导入和导出语句我们可以**清晰地看到模块间的依赖关系**。
> - **模块可以借助工具来进行打包**，所以在页面中只需要加载合并后的资源文件，**减少了网络开销**。
> - 多个**模块之间的作用域是隔离的**，彼此不会有命名冲突。

> 2009 年开始，JavaScript 社区开始对模块化进行不断的尝试，并先后给出了 **AMD**、**CommonJS**、**CMD** 等解决方案。

> 在 2015 年，ECMAScript 6.0（ES6）正式定义了 JavaScript 模块标准。

> ES6 模块标准目前已经得到了大多数现代浏览器的支持，
> 但在实际应用方面还需要等待一段时间，主要有以下几点原因：
> - 无法使用代码分片（code splitting）和删除死代码（tree shaking）；
> - 大多数 npm 模块还是 CommonJS 的形式，而浏览器并不支持其语法，因此这些包没有办法直接拿来用；
> - 个别浏览器/平台的兼容性问题；
>
> 那么，如何才能让我们的工程在使用模块化的同时也能正常运行在浏览器中呢？这就到了模块打包工具出场的时候了。

> 模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。
> 
> 它的工作方式主要分为两种：
> 1. **将存在依赖关系的模块按照特定规则合并为单个 JS 文件**，一次全部加载进页面中。
> 2. 在页面初始时**加载一个入口模块，异步加载其他模块**。

>  Webpack 默认支持多种模块标准，包括 AMD、CommonJS 以及最新的 ES6 模块

>  Webpack 有完备的代码分片解决方案。从字面意思去理解，它可以分割打包后的资源，**在首屏只加载必要的部分，将不太重要的功能放到后面动态加载**。这对于**资源体积较大的应用**来说尤为重要，可以**有效地减小资源体积，提升首页渲染速度**。

>  **Webpack 可以处理各种类型的资源**。除了 JavaScript 以外， Webpack 还可以处理**样式、模板，甚至图片等**，而开发者需要做的仅仅是导入它们。

>  **Webpack 拥有庞大的社区支持**。除了 Webpack 核心库以外，还有无数开发者来为它编写周边插件和工具。

### 1.3 安装

> 推荐使用 Node.js 的 **LTS（Long Term Support，长期维护）版本**。
> LTS 版本是 Node.js 在“当前阶段”较为稳定的版本。

> 同时安装了 `webpack` 以及 `webpack-cli`。
> **webpack 是核心模块，webpack-cli则是命令行工具**


### 1.4 打包第一个应用

> **Webpack 为开发者提供了 development、production、none 三种模式**。
> 当置于 development 和 production 模式下时，它**会自动添加适合当前模式的一系列配置，减少了人为的工作量**。

> 1. Webpack 默认的资源输出目录是 /dist，我们不需要做任何改动；
> 2. Webpack 默认的源代码入口就是 src/index.js；
> 3. Webpack 的默认配置文件为 webpack.config.js（也可以使用其他文件名，需要使用命令行参数指定）；

> 上面通过 module.exports 导出了一个对象，也就是打包时被 Webpack 接收的配置对象。

> 在 Webpack 配置中，我们经常会遇到这种层叠的属性关系。这是由于 Webpack 本身的配置实在太多，如果都放在同一级会难以管理，因此出现了这种**多级配置**。

>  Webpack 对于 `output.path` 的要求是使用绝对路径（从系统根目录开始的完整路径），之前我们在命令行中为了简洁而使用了相对路径。而在 webpack.config.js 中，我们通过调用 Node.js 的路径拼装函数 `path.join` ，将 `__dirname`（Node.js 内置全局变量，值为当前文件所在的绝对路径）与 dist（输出目录）连接起来，得到了最终的资源输出路径。

>  Webpack 社区已经为我们提供了一个便捷的本地开发工具：webpack-dev-server。

> 安装指令中的 `-D` 参数是将 webpack-dev-server **作为工程的devDependencies（开发环境依赖）记录在 package.json 中**。

> 假如**工程上线时**要进行依赖安装，就可以**通过 `npm install --only=prod` 过滤掉 devDependencies 中的冗余模块**，从而加快安装和发布的速度。

> 我们在配置中添加了一个 **`devServer` 对象**，它是**专门用来放`webpack-dev-server` 配置**的

> webpack-dev-server 可以看作一个服务者，它的**主要工作就是接收浏览器的请求，然后将资源返回**。
> 当服务启动时，它会
> - 先让 Webpack 进行模块打包并将资源准备好（在示例中就是 bundle.js）；
> - 当 webpack-dev-server 接收到浏览器的资源请求时，它会首先**进行 URL 地址校验**；
>   - 如果该地址是资源服务地址（上面配置的 `publicPath` ），webpack-dev-server 就会从 Webpack 的打包结果中寻找该资源并返回给浏览器。
>   - 反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。

> webpack-dev-server 的两大职能：
> 1. 令 Webpack 进行模块打包，并处理打包结果的资源请求；
> 2. 作为普通的 Web Server，处理静态资源文件请求；

> 直接用 Webpack 开发和使用 webpack-dev-server 有一个很大的区别：
> 
> 前者每次都会生成 main.js，而 webpack-dev-server 只是**将打包结果放在内存中，并不会写入实际的 bundle.js**，在每次 webpack-dev-server 接收到请求时都只是将内存中的打包结果返回给浏览器。
> 
> 这一点可以通过删除工程中的 dist 目录来验证，你会发现即便 dist 目录不存在，刷新页面后功能仍然是正常的。
> 
> 从开发者的角度来看，这其实是符合情理的。
> 在本地开发阶段我们经常会调整目录结构和文件名，如果每次都写入实际文件，最后就会产生一些没用的垃圾文件，还会干扰我们的版本控制，因此 webpack-dev-server 的处理方式显得更加简洁。

> webpack-dev-server 还有一项很便捷的特性——**live-reloading（自动刷新）**。
> 在后面我们还会讲到更先进的 **hot-module-replacement（模块热替换）**，甚至不需要刷新浏览器就能获取更新之后的内容。

