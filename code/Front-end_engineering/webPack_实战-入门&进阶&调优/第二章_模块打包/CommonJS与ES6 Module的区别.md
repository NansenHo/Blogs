# CommonJS 和 ES6 Module 的区别

## CommonJS 与 ES6 Module 最本质的区别

1. 前者对模块依赖的解决是 “动态的”
   
   即，模块依赖关系的建立发生在**代码运行阶段**

   > 模块A在加载模块B时会执行B中的代码，并将其module.exports对象作为require函数的返回值返回。
   > require的模块路径可以动态指定，支持传入一个表达式，甚至可以通过if语句判断是否加载某个模块。
   > 因此，在CommonJS模块被执行前，我们并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

2. 后者是 “静态的”
   
   即，模块依赖关系的建立发生在**代码编译阶段**
   
   > ES6 Module的导入、导出语句都是声明式的，它不支持将表达式作为导入路径，并且导入、导出语句必须位于模块的顶层作用域（比如不能放在 if 语句中）。
   > 因此我们说，ES6 Module是一种静态的模块结构，在ES6代码的编译阶段就可以分析出模块的依赖关系。


## ES6 Module 相比 CommonJS 的优势

1. 死代码检测和排除

我们可以用静态分析工具检测出哪些模块没有被调用过。

在引入工具类库时，工程中往往只用到了其中一部分组件或接口，但有可能会将其代码完整地加载进来。未被调用到的模块代码永远不会被执行，也就成了死代码。通过静态分析可以在打包时去掉这些未曾使用过的模块，以减小打包资源体积。

2. 模块变量类型检查

JavaScript属于动态类型语言，不会在代码执行前检查类型错误（比如对一个字符串类型的值进行函数调用）。ES6 Module的静态模块结构有助于确保模块之间传递的值或接口类型是正确的。

3. 编译器优化

CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而ES6 Module支持直接导入变量，减少了引用层级，程序效率更高。

## 值复制与动态映射

在导入一个模块时

1. 对于CommonJS来说获取的是一份导出值的副本；

2. 在ES6 Module中则是值的动态映射，并且这个映射是只读的。

