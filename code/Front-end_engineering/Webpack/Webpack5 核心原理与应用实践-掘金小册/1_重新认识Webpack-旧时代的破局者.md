# 1_重新认识Webpack-旧时代的破局者

## 为什么我们需要 Webpack

在远古时代，我们只能用原生 JavaScript(ES5)、CSS、HTML 方式编写页面代码，
开发与生产环境代码基本一致，开发与运行效率都非常低；
其次，页面的图片、代码、CSS 等资源都能且只能通过 img、 script、link 等标签插入到页面中，我们需要非常精细地管理、设计各个标签出现的位置、顺序，这也会占用我们非常多的精力与注意力。

直到 2009年 Node 与 RequireJS 的出现才打破这一僵局，
让我们在代码被放到浏览器运行起来之前，有机会做一些预处理工作 —— 开发与生产环境终于有了隔离管理的实现方案。
再往后，出现了越来越多解决具体问题的效率工具，我们开始尝试使用 Babel、TypeScript、CoffeeScript 等，绕过 ES5 诸多低效语言特性、陷阱；
尝试通过 Less、Sass、Stylus 等工具，为页面样式开发引入逻辑运算、数学运算、嵌套、继承等结构化语言特性，等等。

这些工程化工具能不同程度弥补浏览器、语言、规范本身的设计缺陷，
我们终于不需要再关注一些低效的技术细节、Trick，
能将更多注意力放在业务代码上，以更高效的方式方法编写出越来越复杂、庞大的 Web 应用。

这个阶段前端领域可谓蓬勃发展，前端工程师的能力边界也在不断扩大，
但却引来了另一个问题：如何管理这些工具与工具背后的工程化逻辑？
我们需要一套足够开放，能融合诸多工程化工具，彻底抹平开发与生产环境差异的一体化工程方案，
这也正是 Webpack 需要解决的问题。

> 在远古阶段，我们写的代码是直接在浏览器上运行，开发和最终运行的代码几乎一样，开发效率很低。
> 2009 年 Node 和 RequireJS 出现后，陆续出现了很多好用的工具让我们可以更高效地工作，比如 Balel（让我们可以放心地使用更新更高级的 JavaScript 写法）、TypeScript、Sass 等。
> 这些工具弥补了浏览器、语言、规范的各种不支持。
> 但工具越来越多，管理这些工具以及为什么要使用某一个工具也成了问题。
> 这个时候，Webpack 这类静态模块打包器就出现了。

## Webpack 是什么

Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，
它能够以一种相对一致且开放的处理方式，
加载应用中的所有资源文件（图片、CSS、视频、字体文件等），
并将其合并打包成浏览器兼容的 Web 资源文件。

### Webpack 之前的模块打包器 

它们有

1. Gulp
2. Grunt
3. RequireJS
4. Browserify
5. Closure Compiler 

它们或简单合并执行多种构建任务；
或聚焦于模块化方案的兼容处理；
或仅仅实现 JavaScript 层面的工程化（合并、压缩、混淆）能力，
都缺乏一个能够兼容处理所有资源、普适的抽象思维框架 —— 这意味着应对不同资源，需要使用不同的特化处理逻辑，且不同类型文件之间无法信息互通。

## Webpack 的特点和优点

Webpack 则忽略具体资源类型之间的差异，将所有代码/非代码文件都统一看作 Module 模块对象，
以相同的加载、解析、依赖管理、优化、合并流程实现打包，
并借助 Loader、Plugin 两种开放接口将资源差异处理逻辑转交由社区实现，
如此来实现统一资源构建模型。

这种设计有很多优点：

1. 所有资源都是 Module，
   所以可以用同一套代码实现诸多特性，包括：代码压缩、Hot Module Replacement、缓存等；

2. 打包时，资源与资源之间非常容易实现信息互换，例如可以轻易在 HTML 插入 Base64 格式的图片；
   
3. 借助 Loader，Webpack 几乎可以用任意方式处理任意类型的资源，
   例如可以用 Less、Stylus、Sass 等预编译 CSS 代码。

甚至在 Webpack 之后出现的许多新打包工具，例如 Rollup、Parcel、Snowpack 等，都或多或少受这种设计影响。

## Webpack 的价值

Webpack 极强的开放性，也让它得以成为前端工程化环境的 基座，
我们可以围绕 Webpack 轻易接入一系列工程化工具，
例如 TypeScript、CoffeScript、Babel 一类的 JavaScript 编译工具；
或者 Less、Sass、Stylus、PostCSS 等 CSS 预处理器；
或者 Jest、Karma 等测试框架，等等。

这些工具都不同程度上补充了 Webpack 不同方面的工程化能力，
使得它能够成为一个大一统的资源处理框架，
满足现代 Web 工程在效率、质量、性能等方面的诉求，
甚至能够应对小程序、微前端、SSR、SSG、桌面应用程序、NPM 包等诸多应用场景。
也因此，即使在当下百花齐放的 Web 工程化领域中，Webpack 依然是最为广泛使用的构建工具之一。

自 2012 年首次发布至今，Webpack 还处于快速迭代成长阶段，社区依然保持极大活力，算是真真正正经得起时间考验的开源项目。
在可预期的未来，Webpack 依然会占据极大市场份额，依然是我们手头上几乎万能的瑞士军刀。

## 充分掌握 Webpack 能构建极强的个人竞争力

如今，Webpack 已经发展的几乎无所不能，但代价则是上手学习成本非常高，学习曲线非常陡峭！
**正是因为 Webpack 很难，静得下心来深挖的人少，所以 深入学习 Webpack，不仅能帮助你更快解决具体的工程技术问题，还能形成属于你个人的，极具区分度的核心竞争力！**

## 如何学习 Webpack

> 类似 Webpack 这么复杂，设计知识点多、深、杂的东西，要怎么去学习呢？
> 答案是：**由浅入深、循序渐进，有章法有体系地学！**

针对 Webpcak 的学习来说，比较好的学习路径：

1. 上手实践各种场景下的构建配置方法，捋清楚最基本的使用规则。

   Webpack 始终是一个工具，就像一把瑞士军刀，无论你多了解它的组成结构，有多精深的理论知识，没有经过大量实战应用，你就始终还是停留在门外汉水平。

   > 通过各种应用场景摸清使用规律，结构化地理解各基础配置项与常见组件的用法。

2. 初步理解底层构建流程，学会分析性能卡点并据此做出正确性能优化。
   
   这部分涉及内容比较广，
   纵向可以深挖到操作系统、计算机网络原理等，
   横向可以扩展到 ECMAScript 规范、多媒体资源编解码等，
   关键在于 **掌握分析方法，理解底层机制，做到融会贯通，举一反三**。

3. 深入 Webpack 扩展规则，理解 Loader 与 Plugin 能做什么，怎么做。
   
   实际上，Webpack 主体只是实现了最核心的构建工具流与 Loader、Plugin 架构，
   大部分具体功能都是通过具体插件与 Loader 实现的，
   所以，学习这两种扩展组件的开发方法，进而理解两者能做什么、怎么做等，能给我们带来以下好处：
   1. 能帮助我们更深层次理解 Webpack 的构建过程；
   2. 在遇到疑难杂症时能帮助我们迅速定位问题位置；
   3. 必要时可以自己上手实现一些定制需求。

4. 深挖源码，理解 Webpack 底层工作原理，加强应用与扩展能力。
   
   经过上面三个步骤，相信你已经成为一个非常成熟的 Webpack 使用者，
   但知其然还需知其所以然，接下来我们还是得深入 Webpack 源码，
   学习从启动构建，到递归编译模块代码，到封装打包，
   再到代码优化最终输出资产文件整个过程，
   只有理解了这个过程我们才算是真正吃透 Webpack 应用到原理整个知识体系，
   才能更深入理解各个配置项到底作用在哪些位置；
   哪些步骤容易造成性能卡点，我们要怎么优化；
   各个 Hook 到底在什么时间点，怎么触发等等。