# 事件循环：宏任务与微任务

[时间循环-微任务与宏任务——现代JavaScript教程](https://zh.javascript.info/event-loop)

目录：
- [事件循环：宏任务与微任务](#事件循环宏任务与微任务)
  - [理论知识](#理论知识)
    - [事件循环：是 JavaScript 引擎在](#事件循环是-javascript-引擎在)
    - [JavaScript 引擎的一般算法：](#javascript-引擎的一般算法)
    - [当我们浏览网页时，JavaScript 引擎仅在](#当我们浏览网页时javascript-引擎仅在)
    - [宏任务队列](#宏任务队列)
  - [三个实际用例理解以上的概念](#三个实际用例理解以上的概念)
    - [1. 拆分 CPU 过载任务](#1-拆分-cpu-过载任务)

## 理论知识

**浏览器中的 JavaScript 执行流程** 和 **Node.js 中的流程** 都是基于 **event-loop 事件循环** 的。

理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。

### 事件循环：是 JavaScript 引擎在

1. **等待任务**
2. **执行任务**
3. **进入休眠状态等待更多任务**

这三个状态之间转换的一个无限循环。

### JavaScript 引擎的一般算法：

1. 有任务时：
   - 从最先进入的任务开始执行
2. 休眠直到出现任务
   - 休眠几乎不消耗 CPU 资源
3. 转到第 1 步

### 当我们浏览网页时，JavaScript 引擎仅在

1. **脚本**
   - 当外部脚本 `<script src="...">` 加载完成时，任务就是执行它。
2. **处理程序**
   - 当用户移动鼠标时，任务就是派生出 `mousemove` 事件和执行处理程序。
3. **事件激活**
   - 当安排的（scheduled）`setTimeout` 时间到达时，任务就是执行其回调。   

时执行，所以大多数时候它并没有执行任何操作。

### 宏任务队列

如果一个任务来临时，JavaScript 引擎正处于繁忙状态，

那么这个任务就会被排入队列，这个队列就是 **宏任务队列 macrotask queue**（V8 术语）。

例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如下图所示。

> 队列中的任务基于 **“先进先出”** 的原则执行。

当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序

![](../../../images/JavaScript/现代%20JavaScript%20教程/宏任务队列例图.jpg)

两个注意点：

1. **JavaScript 引擎在执行任务时，页面永远不会进行渲染（render）**
   - 如果任务执行需要很长一段时间也没关系，
   - 仅在任务完成后才会绘制对 DOM 的更改。
2. **如果一项任务执行花费的时间过长，浏览器将无法执行其他任务**
   - 所以，在一定时间后，浏览器会抛出一个如 “页面未响应” 之类的警报，建议你终止这个任务。
   - 这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。

## 三个实际用例理解以上的概念

### 1. 拆分 CPU 过载任务

比如我们打开一个文本量巨大文档页面，里面写了大量的代码。给这些代码进行语法高亮就是一件相当耗费 CPU 的任务。

引擎需要执行分析、创建很多着色元素，然后将其添加到文档中。当引擎忙于语法高亮时，就没法操作页面了。

这可能导致浏览器 **中断（hiccup）** 甚至 **挂起（hang）** 一段时间（不可接受）。

我们这个时候就可以

1. 先高亮显示前 100或多少行
2. 剩余的再用 setTimeout（延时参数为 0 ） 来将这么多代码拆分成多段来执行

这样引擎干完 100 行，如果有别的事就可以先去干别的事，干完了再来 100 行 100 行地做剩下的。

引擎干完 100 行是很快的。这样做的话，JS 引擎既把文本高亮了，又不会没空去处理用户的页面操作。

这样用户在页面上就不会遇到页面无法响应的情况。

```javascript
let i = 0,
    start = Date.now();

function count() {
   // 做一个繁重的任务
   for (let j = 0; j < 1e10; j++) {
     i++;
   }
   alert("Done in " + (Date.now() - start) + 'ms');
}
count();
```

执行上面的代码，我的电脑花了 40 多秒，
这段时间我做的一系列页面操作都无法立即响应，
比如我做了以下操作：
1. 点击了“zzz”链接
2. 点击了“xxx”链接
3. 点击了“yyy”链接
在函数执行结束后，浏览器会立即去执行第 3 个即最后一个操作。

```javascript
let i = 0,
    start = Date.now();
function count() {
   // 把 1e9 拆分成 1000 个 1e6 来做
   do {
      i++
   } while (i % 1e6 !== 0);
   // 
   if (i === 1e9) {
      alert(`Done in ${Date.now() - start} ms`);
   } else {
      setTimeout(count);
   }
}
count();
```

> `do ... while` 语句创建一个执行指定语句的循环，直到 condition 值为 false。
> ```javascript
> do 
>    statement
> while (condition);
> ```
> statement 如果想写多条语句，就可以用 块`{}` 包裹起来。
 
注意，是否使用了 `setTimeout` 对任务进行拆分，在执行速度上和完全不拆分任务执行是相当的/很接近的。在执行计数的总耗时上没有多少差异。

但我们还可以让两者的总耗时更加地接近。

```javascript
let i = 0,
    start = Date.now();
function count() {
   // 把调用 count 放到前面来做
   if (i < 1e9 - 1e6) {
      setTimeout(count);
   }

   // 把 1e9 拆分成 1000 个 1e6 来做
   do {
      i++
   } while (i % 1e6 !== 0);

   if (i === 1e9) {
      alert(`Done in ${Date.now() - start} ms`);
   }
}
count();
```

> 前置的 setTimeout 调度在我的电脑上执行了 4.8 秒；
> 后置的 setTimeout 调度则执行了 8.1 秒。

前置 `setTimeout(count)` 会让函数立即安排它。
而**多个嵌套的 setTimeout 调用在浏览器中的最小延迟为 4ms，即使我们设置了 延迟为 0，但还是会有 4ms（或者更久）**。
所以**我们将 `setTimeout` 安排得越早，运行速度也就会越快**。