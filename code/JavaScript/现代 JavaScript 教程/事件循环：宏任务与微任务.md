# 事件循环：宏任务与微任务

[时间循环-微任务与宏任务——现代JavaScript教程](https://zh.javascript.info/event-loop)

## 理论知识

**浏览器中的 JavaScript 执行流程** 和 **Node.js 中的流程** 都是基于 **event-loop 事件循环** 的。

理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。

### 事件循环：是 JavaScript 引擎在

1. 等待任务
2. 执行任务
3. 进入休眠状态等待更多任务

这三个状态之间转换的一个无限循环。

### JavaScript 引擎的一般算法：

1. 有任务时：
   - 从最先进入的任务开始执行
2. 休眠直到出现任务
   - 休眠几乎不消耗 CPU 资源
3. 转到第 1 步

### 当我们浏览网页时，JavaScript 引擎仅在 

1. 脚本
   - 当外部脚本 `<script src="...">` 加载完成时，任务就是执行它。
2. 处理程序
   - 当用户移动鼠标时，任务就是派生出 `mousemove` 事件和执行处理程序。
3. 事件激活
   - 当安排的（scheduled）`setTimeout` 时间到达时，任务就是执行其回调。   

时执行，所以大多数时候它并没有执行任何操作。

### 宏任务队列

如果一个任务来临时，JavaScript 引擎正处于繁忙状态，

那么这个任务就会被排入队列，这个队列就是 **宏任务队列 macrotask queue**（V8 术语）。

例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如下图所示。

> 队列中的任务基于 **“先进先出”** 的原则执行。

当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序

![](../../../images/JavaScript/现代%20JavaScript%20教程/宏任务队列例图.jpg)

两个注意点：

1. **JavaScript 引擎在执行任务时，页面永远不会进行渲染（render）**
   - 如果任务执行需要很长一段时间也没关系，
   - 仅在任务完成后才会绘制对 DOM 的更改。
2. **如果一项任务执行花费的时间过长，浏览器将无法执行其他任务**
   - 所以，在一定时间后，浏览器会抛出一个如 “页面未响应” 之类的警报，建议你终止这个任务。
   - 这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。


## 三个实际用例理解以上的概念

### 1. 拆分 CPU 过载任务

比如我们打开一个文本量巨大文档页面，里面写了大量的代码。给这些代码进行语法高亮就是一件相当耗费 CPU 的任务。

引擎需要执行分析、创建很多着色元素，然后将其添加到文档中。当引擎忙于语法高亮时，就没法处理其他 DOM 操作了。

这可能导致浏览器**中断（hiccup）**甚至**挂起（hang）**一段时间（不可接受）。

我们这个时候就可以

1. 先高亮显示前 100或多少行
2. 剩余的再用 setTimeout（延时参数为 0 ） 来将这么多代码拆分成多段来执行

这样引擎就可以去做别的事。









