# 引擎、编译器和作用域

## 引擎 & 编译器 & 作用域

用 3 个角色来理解 JavaScript 程序的处理过程：

1. 引擎
   - 负责 JavaScript 的整个编译&执行过程。
2. 编译器
   - 负责词法分析及代码生成等
3. 作用域
   - 负责收集并维护所有变量组成的一系列查询
   - 根据规则确定当前执行代码对这些变量的访问权限

> 编译器 和 作用域 就像是 引擎 的左右手，帮引擎处理了很多工作。

### `var a = 2;` 被如何处理

1. 编译器：看到 `var a` 会先去找作用域，看看该作用域中是否已经存在该变量；
   - 如果已存在，编译器就会忽略该声明，接着往下编译；
   - 如果没有，编译器就会在当前作用域中声明一个新的变量，并命名为 a ；
2. 编译器：为引擎生成运行需要的代码。这些代码被用于处理 `a = 2` 这个赋值操作；
3. 引擎：去询问作用域，该作用域中是否已存在 `a` 变量；
   - 如果已存在，引擎会直接使用这个变量，并进行赋值操作；
   - 如果没有，引擎会继续查找这个变量；如果找不到就会抛出一个异常。

### 引擎如何查找变量：RHS 和 LHS

引擎在拿到编译器生成运行代码 `a = 2` 后，就会在作用域的协助下，去查找变量 `a` 是否声明过。

引擎查找变量，一共有两种方式：`RHS` 和 `LHS`：

1. 当变量出现在赋值操作的左侧时，进行 `LHS` 操作；
   LHS 查询是试图找到变量的容器本身。
   函数的声明不应该被理解成 LHS查询和赋值 的形式；
2. 当操作是得到变量的源值（Retrieve his source value）时，进行 `RHS` 操作； 
   RHS 查询与简单地查找某个变量的值没有区别。

```javascript
// RHS
console.log(a);

// LHS
a = 2;
```

```javascript
function foo (a) {
   console.log(a);
}
foo(2);
```

上面代码，引擎和作用域会发生以下互动：

- 引擎：作用域，我要为 foo 进行 RHS 引用，你见过它吗？
- 作用域：有的，编译器刚声明的，是一个函数，我给你。
- 引擎：执行 foo ...
- 引擎：作用域，我要为 a 进行 LHS 引用，你有见过它吗？
- 作用域：有的，编译器把它声明成了一个 foo 的形式参数了，我给你。
- 引擎：把 2 赋值给 a ...
- 引擎：作用域，我要为 console 进行 RHS 引用，你见过它吗？
- 作用域：有的，console 是一个内置对象，给你。
- 引擎：我看看里面是不是有 log() ，找到了，是一个函数。
- 引擎：作用域，你能帮我再确认一下对 a 的 RHS 引用吗？
- 作用域：放心，这个变量没有变过，拿去吧。
- 引擎：拿到 a 的值并把它传进 log() 里。





