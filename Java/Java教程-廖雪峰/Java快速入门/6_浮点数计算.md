# 浮点数计算

## 浮点数计算

浮点数只能进行加减乘除计算，不能做位运算和移位运算。

浮点数 `0.1` 在计算机中就无法精确表示，因为十进制的 `0.1` 换算成二进制是一个无限循环小数。

很显然，无论使用 `float` 还是 `double`，都只能存储一个 `0.1` 的近似值。

因为浮点数常常无法精确表示，因此，浮点数运算会产生误差。

直接比较两个浮点数是否相等也常常会出现错误的结果。

比较两个浮点数的方法：

```java
// 先计算 x 和 y 差的绝对值
double r = Math.abs(x - y)

// 再判断绝对值是否足够小：
if (r < 0.00001) { 
	return true
} else {
	return false
}
```

浮点数在内存的表示方法和整数比更加复杂。

Java 的浮点数完全遵循 [IEEE-754](https://web.archive.org/web/20070505021348/http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html) 标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。

## 类型提升

如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型。

```java
int n = 5;
// 24.0 / 5.0 等于 4.8
double d = 1.2 + 24.0 / n; // 6.0
System.out.println(d);
```

但两个整数的运算不会出现自动提升的情况。

```java
double d = 1.2 + 24 / 5; // 5.2
```

计算结果为 `5.2`，原因是编译器计算 `24 / 5` 这个子表达式时，按两个整数进行运算，结果仍为整数 `4`。

## 溢出

整数运算在除数为 `0` 时会报错，而浮点数运算在除数为 `0` 时，不会报错，但会返回几个特殊值：

- `NaN` 表示 `Not a Number`
- `Infinity` 表示无穷大
- `-Infinity` 表示负无穷大

```java
double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity
```

## 强制转型

可以将浮点数强制转型为整数。

在转型时，浮点数的小数部分会被丢掉。

如果转型后超过了整型能表示的最大范围，将返回整型的最大值。

```java
int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
```

```java
// 实现四舍五入
double d = 2.6;
int n = (int) (d + 0.5);
System.out.println(n);
```
