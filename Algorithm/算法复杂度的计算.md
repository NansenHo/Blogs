# 算法复杂度的计算 {ignore=true}

[toc]

## 时间复杂度 & 空间复杂度

算法复杂度是指算法在编写成可执行程序后，运行所需的**内存资源**和**时间资源**。

算法复杂度通过时间复杂度和空间复杂度来表示。

- 时间复杂度：算法速度快慢。

- 空间复杂度：算法占用空间大小。

分别是快与省。越快越省的算法就越好。

## 时间复杂度 bigO

从时间维度来衡量算法的好坏，其实是很简单的，直接放到机器上一跑，就可以知道执行时间有多久。

但是机器的好坏也会影响执行的时间，所以这样的一个时间是没有多大意义的。

我们应该计算的是一个**渐进时间复杂度**，表示数据规模增大后，算法执行时间的增长趋势。

bigO 时间复杂度表示法并不能真正反应一个算法的执行时间，而只是反应了时间增长的趋势。

### 时间复杂度的公式

$ T(n) = O(f(n)) $

|  | 解释 |
| :---: | :--- |
| $T(n)$ | 算法的渐进时间复杂度 |
| $f(n)$ | 代码执行的次数 |
| $O$ | 正比例关系 |

### 单层 for 循环的时间复杂度

```js
for (let i=1; i<=n; i++) {
    console.log(i)
}
```

`let i = 1` 执行一次，`i <= n`、`i++`、`x++` 分别执行 n 次。

时间复杂度为 $O(1 + 3N)$，由于在 n 接近无限大的时候，+1(加一个常数) 和 *3 都意义不大了，bigO 表示法下为 $O(N)$。

### 双层 for 循环的时间复杂度

```js
for (let i=1; i<=n; i++) {
    for(let j=1; j<=n; j++) {
        console.log(i)
    }
}
```

时间复杂度用 bigO 表示法为 $O(n^2)$

### 一个双层循环加一个单层循环的时间复杂度

```js
for (let i=1; i<=n; i++) {
    console.log(i)
}
for (let i=1; i<=n; i++) {
    for (let j=1; j<=n; j++) {
        console.log(i)
    }
}
```
时间复杂度为 $O(n + n^2)$

但 $n$ 和 $n^2$ 相比，就像是一个常量一样，是没有意义的。

在 bigO 表示法下，可以直接写成 $O(n^2)$

### 常用时间复杂度量级

按复杂度由低到高排列，依次是：

1. 常阶级 $O(1)$
2. 对数阶 $O(logN)$

3. 线性阶 $O(n)$
4. 线性对数阶 $O(nlogN)$
   
5. 平方阶 $O(n^2)$
6. 立方阶 $O(n^3)$
7. K 次方阶 $O(n^k)$
8. 指数阶 $2^n$
9. 阶乘 $O(n!)$

其中，

- 平方阶 $O(n^2)$
- 立方阶 $O(n^3)$
- K 次方阶 $O(n^k)$
- 指数阶 $2^n$
- 阶乘 $O(n!)$ 

随着数据规模增大，算法执行时间的增长趋势是**指数级**的。

如果一个算法的时间复杂度达到以上这么高，那这个算法是非常非常慢的。

- 常阶级 $O(1)$
- 对数阶 $O(logN)$
- 线性阶 $O(n)$
- 线性对数阶 $O(nlogN)$ 

随着数据规模增大，算法执行时间的增长趋势是**线性的**。

#### 时间复杂度为 $O(1)$ 的算法示例

```js
let x = 0,
    y = 1,
    temp = x;
x = y
y = temp;
```

上面我堆对调了 x 和 y 的值。

该算法的执行时间不会因为 x y temp 其中任何一个变量数据增大而增加。

所以时间复杂度为 $O(1)$。

#### 时间复杂度为 $O(n)$ 的算法示例

```js
for (let i=1; i<n; i++) {
    console.log(i)
}
```

#### 时间复杂度为 $O(logN)$ 的算法示例

```js
let i = 1
while (i < n) {
    i = i * 2
}
```

要循环多少次，i 才会大于等于 n。

由 $i = 1$，我们很容易得知 $2^k = n$ 。

k 就是循环的次数。

最后得到 $k = logN$。

#### 时间复杂度为 $O(nlogN)$ 的算法示例

```js
for (let i=0; i<n; i++) {
    let x = 1
    while (x < n) {
        x = x * 2
    }
}
```

$O(nlogN)$ 很好理解，就是 $O(n)$ 乘以一个 $O(logN)$，在 $O(logN)$ 的外面加一层 for 循环。

#### 时间复杂度为 $O(n^2)$ 的算法示例

```js
for (let i=1; i<=n; i++) {
    for (let j=1; j<=n; j++) {
        console.log(i, j)
    }
}
```

如果是这样的一个双层循环：

```js
for (let i=1; i<=n; i++) {
    for (let j=1; j<=m; j++) {
        console.log(i, j)
    }
}
```

那它的算法复杂度为 $O(nm)$

## bigO 之外的其他复杂度指标

| 复杂度指标 | 说明 |
| :---: | :--- |
| O | big O, 求的是最差情况。是最常用的指标。|
| $\Omega$ | big Omega, 求的是最好情况。|
| $\theta$ | big thera, 求的是一个算法的区间。| 

## 空间复杂度

空间复杂度指的是，内存空间增长的趋势。

### 常用的空间复杂度量级

1. $O(1)$
2. $O(n)$
3. $O(n^2)$

#### 空间复杂度为 $O(1)$ 的算法示例

```js
let x = 0
let y = 0
x++
y++
```

上面需要的空间是一个常数量，所以是 $O(1)$。

#### 空间复杂度为 $O(n)$ 的算法示例

```js
let arr = []
for (let i=0; i<n; i++) {
    arr[i] = i
}
```

该空间复杂度取决于 n 的值，n 的值越大，arr 的长度越大。

#### 空间复杂度为 $O(n^2)$ 的算法示例

一个矩阵是由 n 行和 n 列组成的。空间复杂度就为 $O(n^2)$。

## 总结

时间空间复杂度 = 时间和空间增长的趋势

## Questions

> 如果一个算法我从 1000n 优化到 2n，按照这种算法我的时间复杂度依然是 O(n)，那不是说明我的优化不起作用？
>
> 在 n 无限大的情况下，比如 n = 1000万亿，那么 1000n 到 2n 中的这种常数倍优化是可以忽略不计的，因为倍数造成的影响是很小的。但是如果能将 1000n 优化成 logn，那就非常有意义了。
> 在实践中，你说提出的这些优化很有意义，只不过在在理论分析中，我们习惯考虑最差的情况，也就是在 n 无限大时的复杂度。