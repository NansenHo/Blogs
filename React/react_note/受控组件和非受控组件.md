# 受控组件和非受控组件

在 HTML 中，表单元素（如 `<input>` `<textarea>` 和 `<select>`）通常自己维护 `state` ，并根据用户输入进行更新。

而在 React 中，**可变状态（mutable state）**通常保存在组件的 `state` 属性中，并且只能通过使用 `setState()` 来更新。

我们对某个组件状态的掌控，它的值是否只能由用户设置，而不能通过代码控制。

比如现在有一个 `input` :

`value` 和 `onChange` 都由代码掌控，这就是受控组件。

```jsx
const NoteSection: React.FC = () => {
  let [note, setNote] = useState('')
  // 每次输入都会被打印出来
  console.log(note)
  return (
   <Wrapper>
    <label>
      <span>备注：</span>
      <input type="text"
             // value 和 onChange 都由代码掌控，这就是受控组件。
             value={note}
             onChange={ (e) => setNote(e.target.value) }
      />
    </label>
   </Wrapper> 
  )
}
```

如果改成非受控组件来做，就是以下的样子：

```jsx
const NoteSection: React.FC = () => {
  const [note, setNote] = useState('')
  // 因为 input 的 value 没法直接给到 note ，
  // 所以只能通过 ref 拿 input element 上的 value 来给到 note
  const ref_input = useRef<HTMLInputELement>(null)
  // 只会打印出鼠标离开的时候，input 里面的值
  console.log(note)
  const getNote = () => {
    if (ref_input !== null) {
      setNote(ref_input.current.value)
    }
  }
  return (
   <Wrapper>
    <label>
      <span>备注：</span>
      <input type="text" 
             // 不再需要使用 value 和 onChange ，不用关注 value 如何变化
             ref={ref_input}
             defaultValue={note}
             onBlur={getNote}
      />
    </label>
   </Wrapper> 
  )
}
```

如果你并不想关心 input 在输入中间发生的每次变化，那你可以用非受控组件，这样它只会告诉你最后用户输入的是什么值。

反之，你如果希望详细地知道用户输入的每次变化，病做一些处理就使用受控组件来实时监听。

> 非受控组件很像 Vue 里面的 `.lazy` 修饰符， `v-model.lazy="value"` 。
> 这样 `value` 就不会实时变化，而是鼠标移出后再变化。

在大多数情况下，我们**推荐使用受控组件来处理表单数据**。在一个受控组件中，表单数据是由 React 组件来管理的。

使用非受控组件的话，表单数据将由 DOM 节点来处理。

> React 推荐使用 **受控组件** 来实现对表单数据的获取。